name: Random KMS Verification

on:
  # Run every 10 minutes with adaptive probability (targets 4 verifications per day)
  # Probability increases if rolling average falls below target
  # This creates a 10-minute attack window
  # Note: GitHub Actions enforces minimum ~5-10 minute intervals for scheduled workflows
  schedule:
    - cron: '*/10 * * * *'  # Every 10 minutes

  # Manual trigger for testing
  workflow_dispatch:

permissions:
  contents: read
  actions: read  # Required to fetch workflow run history

jobs:
  maybe-trigger-verification:
    name: Random Verification Trigger
    runs-on: ubuntu-latest

    steps:
      - name: Calculate adaptive probability
        id: probability
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üìä Calculating adaptive probability based on recent verification history..."
          echo ""

          # Fetch last 50 verify.yml runs and filter for successful ones
          RECENT_VERIFICATIONS=$(gh run list \
            --workflow="verify.yml" \
            --repo ${{ github.repository }} \
            --json conclusion,createdAt,status \
            --limit 50 \
            | jq '[.[] | select(.conclusion == "success")] | .[0:12]')

          # Count how many successful verifications we have
          VERIFICATION_COUNT=$(echo "$RECENT_VERIFICATIONS" | jq 'length')
          echo "Found $VERIFICATION_COUNT successful verifications in recent history"

          # Default probability (1/36 = ~4 verifications per day)
          DENOMINATOR=36

          if [ "$VERIFICATION_COUNT" -eq 0 ]; then
            # No verifications yet - use aggressive probability
            DENOMINATOR=4
            echo "‚ö†Ô∏è  No recent verifications found - using aggressive probability (1/$DENOMINATOR)"
          elif [ "$VERIFICATION_COUNT" -ge 2 ]; then
            # Get oldest and newest timestamps
            OLDEST=$(echo "$RECENT_VERIFICATIONS" | jq -r '.[-1].createdAt')
            NEWEST=$(echo "$RECENT_VERIFICATIONS" | jq -r '.[0].createdAt')

            # Convert to epoch seconds
            OLDEST_EPOCH=$(date -d "$OLDEST" +%s)
            NEWEST_EPOCH=$(date -d "$NEWEST" +%s)
            CURRENT_EPOCH=$(date +%s)

            # Calculate timespan in hours
            TIMESPAN_SECONDS=$((NEWEST_EPOCH - OLDEST_EPOCH))
            TIMESPAN_HOURS=$(echo "scale=2; $TIMESPAN_SECONDS / 3600" | bc)

            # Calculate rolling rate (verifications per day)
            if (( $(echo "$TIMESPAN_HOURS > 0" | bc -l) )); then
              ROLLING_RATE=$(echo "scale=2; $VERIFICATION_COUNT / ($TIMESPAN_HOURS / 24)" | bc)
            else
              # All verifications within same hour - assume we're doing fine
              ROLLING_RATE=4.0
            fi

            echo "Timespan: $TIMESPAN_HOURS hours"
            echo "Rolling rate: $ROLLING_RATE verifications/day (target: 4.0/day)"

            # Adjust probability based on rolling rate
            if (( $(echo "$ROLLING_RATE >= 4.0" | bc -l) )); then
              DENOMINATOR=36
              echo "‚úÖ On target or above - using default probability (1/$DENOMINATOR)"
            elif (( $(echo "$ROLLING_RATE >= 3.0" | bc -l) )); then
              DENOMINATOR=27
              echo "‚ö° Slightly below target - boosting probability by 33% (1/$DENOMINATOR)"
            elif (( $(echo "$ROLLING_RATE >= 2.0" | bc -l) )); then
              DENOMINATOR=18
              echo "‚ö°‚ö° Below target - boosting probability by 100% (1/$DENOMINATOR)"
            elif (( $(echo "$ROLLING_RATE >= 1.0" | bc -l) )); then
              DENOMINATOR=9
              echo "‚ö°‚ö°‚ö° Well below target - boosting probability by 400% (1/$DENOMINATOR)"
            else
              DENOMINATOR=4
              echo "üö® Critically below target - using aggressive probability (1/$DENOMINATOR)"
            fi

            # Special case: if last verification was > 24h ago, force high probability
            HOURS_SINCE_LAST=$(echo "scale=2; ($CURRENT_EPOCH - $NEWEST_EPOCH) / 3600" | bc)
            echo "Hours since last verification: $HOURS_SINCE_LAST"

            if (( $(echo "$HOURS_SINCE_LAST >= 24" | bc -l) )); then
              DENOMINATOR=1
              echo "üö® CRITICAL: No verification in 24+ hours - FORCING verification (1/$DENOMINATOR)"
            elif (( $(echo "$HOURS_SINCE_LAST >= 18" | bc -l) )); then
              DENOMINATOR=4
              echo "‚ö†Ô∏è  No verification in 18+ hours - using aggressive probability (1/$DENOMINATOR)"
            fi
          else
            # Only 1 verification - not enough data, use default
            echo "‚ÑπÔ∏è  Insufficient data (only 1 verification) - using default probability (1/$DENOMINATOR)"
          fi

          echo ""
          echo "Final probability: 1/$DENOMINATOR"
          echo "denominator=$DENOMINATOR" >> $GITHUB_OUTPUT

      - name: Roll the dice
        id: dice
        run: |
          DENOMINATOR=${{ steps.probability.outputs.denominator }}

          # Generate random number between 0 and (DENOMINATOR - 1)
          ROLL=$((RANDOM % DENOMINATOR))
          echo "üé≤ Dice roll: $ROLL (need 0 to trigger, probability: 1/$DENOMINATOR)"

          if [ $ROLL -eq 0 ]; then
            echo "‚úÖ Lucky roll! Triggering verification..."
            echo "trigger=true" >> $GITHUB_OUTPUT
          else
            echo "‚è≠Ô∏è  Not this time. Next check in 10 minutes."
            echo "trigger=false" >> $GITHUB_OUTPUT
          fi

      - name: Trigger verification workflow
        if: steps.dice.outputs.trigger == 'true'
        env:
          GH_TOKEN: ${{ secrets.VERIFICATION_TRIGGER_TOKEN }}
        run: |
          # Note: repository_dispatch only works on default branch
          # We use gh workflow run to trigger verify.yml on verifier branch
          gh workflow run verify.yml \
            --ref verifier \
            -R ${{ github.repository }}

          echo "‚úÖ Verification workflow triggered on verifier branch"
          echo "Check: https://github.com/${{ github.repository }}/actions/workflows/verify.yml"

      - name: Log skip
        if: steps.dice.outputs.trigger == 'false'
        run: |
          DENOMINATOR=${{ steps.probability.outputs.denominator }}
          echo "‚ÑπÔ∏è  Skipped this time (probability was 1/$DENOMINATOR)"
          echo "Next check in 10 minutes with adaptive probability"
