function f(e){let t=new Uint8Array(e),r=Array.from(t,s=>String.fromCharCode(s)).join("");return btoa(r).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/g,"")}function O(e){if(e.length!==65||e[0]!==4)throw new Error("Invalid uncompressed P-256 public key");let t=f(e.slice(1,33).buffer),r=f(e.slice(33).buffer);return{kty:"EC",crv:"P-256",x:t,y:r}}async function W(e){let t={crv:e.crv,kty:e.kty,x:e.x,y:e.y},r=JSON.stringify(t),n=await crypto.subtle.digest("SHA-256",new TextEncoder().encode(r));return f(n)}function Ce(e){return"{"+Object.keys(e).sort().map(n=>[n,e[n]]).map(([n,s])=>`"${String(n)}":${JSON.stringify(s)}`).join(",")+"}"}function Z(e){let t={kmsVersion:e.kmsVersion,method:e.method,algVersion:e.algVersion,purpose:e.purpose};e.credentialId&&(t.credentialId=f(e.credentialId));let r=Ce(t);return new TextEncoder().encode(r).buffer}function ee(e){let t={kmsVersion:e.kmsVersion,kid:e.kid,alg:e.alg,purpose:e.purpose,createdAt:e.createdAt,keyType:e.keyType},r=Ce(t);return new TextEncoder().encode(r).buffer}async function de(e){let t=await crypto.subtle.exportKey("raw",e),r=await crypto.subtle.importKey("raw",t,{name:"HMAC",hash:"SHA-256"},!1,["sign"]),n=new TextEncoder().encode("ATS/KMS/KCV/v2");return await crypto.subtle.sign("HMAC",r,n)}function Re(e,t){return ht(e,t)}function ht(e,t){let r=new Uint8Array(e),n=new Uint8Array(t);if(r.length!==n.length)return!1;let s=0;for(let a=0;a<r.length;a++)s|=r[a]^n[a];return s===0}async function H(e){return await crypto.subtle.digest("SHA-256",new TextEncoder().encode(e))}async function Ve(e={min:150,max:300,mid:220}){let t=await crypto.subtle.importKey("raw",new TextEncoder().encode("calibration"),"PBKDF2",!1,["deriveBits"]),r=crypto.getRandomValues(new Uint8Array(16)),n=1e5,s=performance.now();await crypto.subtle.deriveBits({name:"PBKDF2",hash:"SHA-256",salt:r,iterations:n},t,256);let u=performance.now()-s,i=Math.round(n*e.mid/u);return i=Math.min(Math.max(i,5e4),2e6),{iterations:i,measuredMs:u}}var At="kms-v2",bt=1,L=null;async function te(){return new Promise((e,t)=>{let r=indexedDB.open(At,bt);r.onerror=()=>{t(new Error("Failed to open IndexedDB"))},r.onsuccess=()=>{L=r.result,e()},r.onupgradeneeded=n=>{let s=n.target.result;if(s.objectStoreNames.contains("config")||s.createObjectStore("config",{keyPath:"method"}),!s.objectStoreNames.contains("keys")){let a=s.createObjectStore("keys",{keyPath:"kid"});a.createIndex("by-purpose","purpose",{unique:!1}),a.createIndex("by-createdAt","createdAt",{unique:!1})}if(!s.objectStoreNames.contains("leases")){let a=s.createObjectStore("leases",{keyPath:"leaseId"});a.createIndex("by-userId","userId",{unique:!1}),a.createIndex("by-exp","exp",{unique:!1})}if(!s.objectStoreNames.contains("audit")){let a=s.createObjectStore("audit",{autoIncrement:!0});a.createIndex("by-seqNum","seqNum",{unique:!0}),a.createIndex("by-timestamp","timestamp",{unique:!1}),a.createIndex("by-op","op",{unique:!1}),a.createIndex("by-kid","kid",{unique:!1})}s.objectStoreNames.contains("meta")||s.createObjectStore("meta",{keyPath:"key"})}})}async function q(){if(L||await te(),!L)throw new Error("Database not initialized");return L}function Te(){L&&(L.close(),L=null)}async function re(e,t){let r=await q();return new Promise((n,s)=>{let i=r.transaction(e,"readonly").objectStore(e).get(t);i.onsuccess=()=>{n(i.result)},i.onerror=()=>{s(new Error(`Failed to get from ${e}`))}})}async function $(e,t){let r=await q();return new Promise((n,s)=>{let i=r.transaction(e,"readwrite").objectStore(e).put(t);i.onsuccess=()=>{n()},i.onerror=()=>{s(new Error(`Failed to put to ${e}`))}})}async function le(e,t){let r=await q();return new Promise((n,s)=>{let i=r.transaction(e,"readwrite").objectStore(e).delete(t);i.onsuccess=()=>{n()},i.onerror=()=>{s(new Error(`Failed to delete from ${e}`))}})}async function Kt(e){let t=await q();return new Promise((r,n)=>{let u=t.transaction(e,"readonly").objectStore(e).getAll();u.onsuccess=()=>{r(u.result)},u.onerror=()=>{n(new Error(`Failed to getAll from ${e}`))}})}async function D(e,t,r,n=e.algorithm,s=e.usages,a={alg:"unknown",purpose:"unknown"}){let u=crypto.getRandomValues(new Uint8Array(12)),i=Date.now(),c=ee({kmsVersion:2,kid:r,alg:a.alg,purpose:a.purpose,createdAt:i,keyType:Array.isArray(s)?s.join(","):String(s)}),l=e.type==="private"?"pkcs8":"raw",o=await crypto.subtle.exportKey(l,e),d=await crypto.subtle.encrypt({name:"AES-GCM",iv:u,additionalData:c},t,o),p={kid:r,kmsVersion:2,wrappedKey:d,iv:u.buffer.slice(u.byteOffset,u.byteOffset+u.byteLength),aad:c,...a.publicKeyRaw!==void 0&&{publicKeyRaw:a.publicKeyRaw},alg:a.alg,purpose:a.purpose,createdAt:i};await $("keys",p)}async function Le(e,t,r,n=[]){let s=await re("keys",e);if(!s)throw new Error(`No wrapped key with id: ${e}`);let a=new Uint8Array(s.iv),u=s.aad,i=await crypto.subtle.decrypt({name:"AES-GCM",iv:a,additionalData:u},t,s.wrappedKey),c=typeof r=="string"?r:r.name,o=c==="ECDSA"||c==="ECDH"||c==="Ed25519"||c.startsWith("RSA")?"pkcs8":"raw";return await crypto.subtle.importKey(o,i,r,!1,n)}async function C(e){return await re("keys",e)??null}async function E(){return Kt("keys")}async function Me(e){await le("keys",e)}async function k(e){let t=await re("meta",e);return t?t.value:null}async function x(e,t){await $("meta",{key:e,value:t})}async function Ue(e){await le("meta",e)}async function Be(e){await $("audit",e)}async function G(){let e=await q();return new Promise((t,r)=>{let u=e.transaction("audit","readonly").objectStore("audit").index("by-seqNum").getAll();u.onsuccess=()=>{t(u.result)},u.onerror=()=>{r(new Error("Failed to get audit entries"))}})}async function je(){let e=await G();return e.length>0?e[e.length-1]:null}async function pe(e){await $("leases",e)}async function N(e){return await re("leases",e)??null}async function ye(e){let t=await q();return new Promise((r,n)=>{let i=t.transaction("leases","readonly").objectStore("leases").index("by-userId").getAll(e);i.onsuccess=()=>{r(i.result)},i.onerror=()=>{n(new Error("Failed to get user leases"))}})}async function J(e){await le("leases",e)}async function Oe(e){let r=(await E()).filter(a=>a.purpose==="vapid");if(r.length===0)throw new Error("No VAPID key found. Generate a VAPID key first.");if(r.length>1)throw new Error("Multiple VAPID keys found. Cannot determine which to update.");let n=r[0];if(!n)throw new Error("No VAPID key found after filtering");let s={...n,subscription:e};await $("keys",s)}async function We(){let t=(await E()).filter(a=>a.purpose==="vapid");if(t.length===0)throw new Error("No VAPID key found");if(t.length>1)throw new Error("Multiple VAPID keys found. Cannot determine which to update.");let r=t[0];if(!r)throw new Error("No VAPID key found after filtering");let{subscription:n,...s}=r;await $("keys",s)}async function fe(){let t=(await E()).filter(n=>n.purpose==="vapid");if(t.length===0)throw new Error("No VAPID key found");if(t.length>1)throw new Error("Multiple VAPID keys found. Cannot determine which to read.");let r=t[0];if(!r)throw new Error("No VAPID key found after filtering");return r.subscription??null}var ne=e=>`enrollment:passphrase:v2:${e}`,se=e=>`enrollment:passkey-prf:v2:${e}`,ae=e=>`enrollment:passkey-gate:v2:${e}`;function we(){let e=new Uint8Array(32);return crypto.getRandomValues(e),e}async function ge(e,t,r){let n=r??we(),{iterations:s}=await Ve(),a=crypto.getRandomValues(new Uint8Array(16)),u=await crypto.subtle.importKey("raw",new TextEncoder().encode(t),"PBKDF2",!1,["deriveKey"]),i=await crypto.subtle.deriveKey({name:"PBKDF2",hash:"SHA-256",salt:a,iterations:s},u,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),c=await de(i),l=crypto.getRandomValues(new Uint8Array(12)),o=Z({kmsVersion:2,method:"passphrase",algVersion:1,purpose:"master-secret"}),d=await crypto.subtle.encrypt({name:"AES-GCM",iv:l,additionalData:o},i,n),p={kmsVersion:2,algVersion:1,method:"passphrase",kdf:{algorithm:"PBKDF2-HMAC-SHA256",iterations:s,salt:a.buffer.slice(a.byteOffset,a.byteOffset+a.byteLength),lastCalibratedAt:Date.now(),platformHash:""},kcv:c,encryptedMS:d,msIV:l.buffer.slice(l.byteOffset,l.byteOffset+l.byteLength),msAAD:o,msVersion:1,createdAt:Date.now(),updatedAt:Date.now()};return await x(ne(e),p),{success:!0,ms:n}}async function me(e,t,r,n,s=""){let a=n??we(),u=await H("ATS/KMS/KEK-wrap/salt/v2"),i=new TextEncoder().encode("ATS/KMS/KEK-wrap/v2"),c=await crypto.subtle.importKey("raw",r,"HKDF",!1,["deriveKey"]),l=await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:u,info:i},c,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]),o=crypto.getRandomValues(new Uint8Array(12)),d=Z({kmsVersion:2,method:"passkey-prf",algVersion:1,credentialId:t,purpose:"master-secret"}),p=await crypto.subtle.encrypt({name:"AES-GCM",iv:o,additionalData:d},l,a),y=Date.now(),w=crypto.getRandomValues(new Uint8Array(32)),K={kmsVersion:2,algVersion:1,method:"passkey-prf",credentialId:t,rpId:s,kdf:{algorithm:"HKDF-SHA256",appSalt:w.buffer.slice(w.byteOffset,w.byteOffset+w.byteLength),hkdfSalt:u,info:"ATS/KMS/KEK-wrap/v2"},encryptedMS:p,msIV:o.buffer.slice(o.byteOffset,o.byteOffset+o.byteLength),msAAD:d,msVersion:1,createdAt:y,updatedAt:y};return await x(se(e),K),{success:!0,ms:a}}async function ke(e,t,r,n=""){let s=r??we(),a=crypto.getRandomValues(new Uint8Array(32)),u=await H("ATS/KMS/KEK-gate/salt/v2"),i=new TextEncoder().encode("ATS/KMS/KEK-gate/v2"),c=await crypto.subtle.importKey("raw",a,"HKDF",!1,["deriveKey"]),l=await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:u,info:i},c,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]),o=crypto.getRandomValues(new Uint8Array(12)),d=Z({kmsVersion:2,method:"passkey-gate",algVersion:1,credentialId:t,purpose:"master-secret"}),p=await crypto.subtle.encrypt({name:"AES-GCM",iv:o,additionalData:d},l,s),y=Date.now(),w={kmsVersion:2,algVersion:1,method:"passkey-gate",credentialId:t,rpId:n,pepperWrapped:a.buffer.slice(a.byteOffset,a.byteOffset+a.byteLength),encryptedMS:p,msIV:o.buffer.slice(o.byteOffset,o.byteOffset+o.byteLength),msAAD:d,msVersion:1,createdAt:y,updatedAt:y};return await x(ae(e),w),{success:!0,ms:s}}async function he(e,t){let r=await k(ne(e));if(!r)return{success:!1,error:"Passphrase not set up"};let n=await crypto.subtle.importKey("raw",new TextEncoder().encode(t),"PBKDF2",!1,["deriveKey"]),s=await crypto.subtle.deriveKey({name:"PBKDF2",hash:"SHA-256",salt:r.kdf.salt,iterations:r.kdf.iterations},n,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),a=await de(s);if(!Re(a,r.kcv))return{success:!1,error:"Invalid passphrase"};try{let u=await crypto.subtle.decrypt({name:"AES-GCM",iv:r.msIV,additionalData:r.msAAD},s,r.encryptedMS);return{success:!0,ms:new Uint8Array(u)}}catch{return{success:!1,error:"Decryption failed"}}}async function Ae(e,t){let r=await k(se(e));if(!r)return{success:!1,error:"Passkey not set up"};let n=r.kdf.hkdfSalt,s=new TextEncoder().encode(r.kdf.info),a=await crypto.subtle.importKey("raw",t,"HKDF",!1,["deriveKey"]),u=await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:n,info:s},a,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]);try{let i=await crypto.subtle.decrypt({name:"AES-GCM",iv:r.msIV,additionalData:r.msAAD},u,r.encryptedMS);return{success:!0,ms:new Uint8Array(i)}}catch{return{success:!1,error:"Decryption failed"}}}async function be(e){let t=await k(ae(e));if(!t)return{success:!1,error:"Passkey gate not set up"};let r=new Uint8Array(t.pepperWrapped),n=await H("ATS/KMS/KEK-gate/salt/v2"),s=new TextEncoder().encode("ATS/KMS/KEK-gate/v2"),a=await crypto.subtle.importKey("raw",r,"HKDF",!1,["deriveKey"]),u=await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:n,info:s},a,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]);try{let i=await crypto.subtle.decrypt({name:"AES-GCM",iv:t.msIV,additionalData:t.msAAD},u,t.encryptedMS);return{success:!0,ms:new Uint8Array(i)}}catch{return{success:!1,error:"Decryption failed"}}}async function qe(e){let t=await k(ne(e)),r=await k(se(e)),n=await k(ae(e));return!!(t||r||n)}async function Ke(e){return!!await k(ne(e))}async function Ie(e){let t=await k(se(e)),r=await k(ae(e));return!!(t||r)}async function _(e){let t=await H("ATS/KMS/MKEK/salt/v2"),r=new TextEncoder().encode("ATS/KMS/MKEK/v2"),n=await crypto.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:t,info:r},n,{name:"AES-GCM",length:256},!1,["encrypt","decrypt","wrapKey","unwrapKey"])}async function R(e,t){let r=Date.now(),n=null;try{let s;switch(e.method){case"passphrase":s=await he(e.userId,e.passphrase);break;case"passkey-prf":s=await Ae(e.userId,e.prfOutput);break;case"passkey-gate":s=await be(e.userId);break;default:throw new Error("Unknown credential method")}if(!s.success)throw new Error(s.error??"Unlock failed");n=s.ms;let a=await _(n),u=await t(a,n),i=Date.now();return{result:u,unlockTime:r,lockTime:i,duration:i-r}}finally{n&&n.fill(0)}}var ve=Promise.resolve(),b=null;async function $e(){}async function ie(){let e=await k("LRK");return e||(e=await crypto.subtle.generateKey({name:"AES-GCM",length:256},!1,["wrapKey","unwrapKey","encrypt","decrypt"]),await x("LRK",e)),e}async function z(e){let t=await crypto.subtle.digest("SHA-256",e);return f(t)}async function S(e){let t=await C("audit-user");if(t&&t.publicKeyRaw){let a=await crypto.subtle.unwrapKey("pkcs8",t.wrappedKey,e,{name:"AES-GCM",iv:t.iv,additionalData:t.aad},{name:"Ed25519"},!1,["sign"]),u=await crypto.subtle.importKey("raw",t.publicKeyRaw,{name:"Ed25519"},!1,["verify"]),i=await z(t.publicKeyRaw);b={type:"UAK",keyPair:{privateKey:a,publicKey:u},keyId:i};return}let r=await crypto.subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),n=await crypto.subtle.exportKey("raw",r.publicKey);await D(r.privateKey,e,"audit-user",{name:"Ed25519"},["sign"],{alg:"EdDSA",purpose:"audit",publicKeyRaw:n});let s=await z(n);b={type:"UAK",keyPair:r,keyId:s}}async function Ge(e,t){if(!b||b.type!=="UAK")throw new Error("UAK must be active to generate LAK - call ensureAuditKey first");let r=Date.now(),n=await crypto.subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),s=await crypto.subtle.exportKey("raw",n.publicKey),a=f(s),u={type:"audit-delegation",version:1,signerKind:"LAK",leaseId:e,delegatePub:a,scope:["vapid:issue","lease:expire"],notBefore:r,notAfter:t,codeHash:"TODO",manifestHash:"TODO",kmsVersion:"v2.0.0"},i=JSON.stringify(u,Object.keys(u).sort()),c=await crypto.subtle.sign("Ed25519",b.keyPair.privateKey,new TextEncoder().encode(i)),l={...u,sig:f(c)},o=await ie(),d=ee({kmsVersion:2,kid:`lak-${e}`,alg:"EdDSA",purpose:"lak",createdAt:r,keyType:"lease-audit-key"}),p=crypto.getRandomValues(new Uint8Array(12)),y=await crypto.subtle.wrapKey("pkcs8",n.privateKey,o,{name:"AES-GCM",iv:p,additionalData:d});return await x(`lease-audit-key:${e}`,{leaseId:e,wrappedKey:y,iv:p,aad:d,publicKeyRaw:s,delegationCert:l,expiresAt:t,createdAt:r}),{lakKeyPair:n,delegationCert:l}}async function Fe(e,t){let r=await k(`lease-audit-key:${e}`);if(!r)throw new Error(`LAK not found for lease: ${e}`);let n=await ie(),s=await crypto.subtle.unwrapKey("pkcs8",r.wrappedKey,n,{name:"AES-GCM",iv:r.iv,additionalData:r.aad},{name:"Ed25519"},!1,["sign"]),a=await crypto.subtle.importKey("raw",r.publicKeyRaw,{name:"Ed25519"},!1,["verify"]),u=await z(r.publicKeyRaw);b={type:"LAK",keyPair:{privateKey:s,publicKey:a},keyId:u,cert:t}}async function He(){let e=await C("audit-instance");if(e&&e.publicKeyRaw){let c=await ie(),l=await crypto.subtle.unwrapKey("pkcs8",e.wrappedKey,c,{name:"AES-GCM",iv:e.iv,additionalData:e.aad},{name:"Ed25519"},!1,["sign"]),o=await crypto.subtle.importKey("raw",e.publicKeyRaw,{name:"Ed25519"},!1,["verify"]),d=await z(e.publicKeyRaw);b={type:"KIAK",keyPair:{privateKey:l,publicKey:o},keyId:d};return}let t=await ie(),r=await crypto.subtle.generateKey({name:"Ed25519"},!0,["sign"]),n=await crypto.subtle.exportKey("raw",r.publicKey);await D(r.privateKey,t,"audit-instance",{name:"Ed25519"},["sign"],{alg:"EdDSA",purpose:"audit-instance",publicKeyRaw:n});let s=await C("audit-instance");if(!s)throw new Error("Failed to retrieve wrapped KIAK after storage");let a=await crypto.subtle.unwrapKey("pkcs8",s.wrappedKey,t,{name:"AES-GCM",iv:s.iv,additionalData:s.aad},{name:"Ed25519"},!1,["sign"]),u=await crypto.subtle.importKey("raw",n,{name:"Ed25519"},!1,["verify"]),i=await z(n);b={type:"KIAK",keyPair:{privateKey:a,publicKey:u},keyId:i}}async function v(e){let t,r,n=new Promise((s,a)=>{t=s,r=a});return ve=ve.then(async()=>{try{if(!b)throw new Error("No active audit signer - call ensureAuditKey, loadLAK, or ensureKIAK first");let s=Date.now(),a=await je(),u=a?a.chainHash:"",c={kmsVersion:2,seqNum:a?a.seqNum+1:1,timestamp:s,op:e.op,kid:e.kid,requestId:e.requestId,userId:e.userId,origin:e.origin,leaseId:e.leaseId,unlockTime:e.unlockTime,lockTime:e.lockTime,duration:e.duration,details:e.details,previousHash:u,signer:b.type,signerId:b.keyId},l=JSON.stringify(c),o=new TextEncoder().encode(u+l),d=await crypto.subtle.digest("SHA-256",o),p=f(d),y=new TextEncoder().encode(p),w=await crypto.subtle.sign("Ed25519",b.keyPair.privateKey,y),K=f(w),P={kmsVersion:c.kmsVersion,seqNum:c.seqNum,timestamp:c.timestamp,op:c.op,kid:c.kid,requestId:c.requestId,userId:c.userId,...c.origin!==void 0&&{origin:c.origin},...c.leaseId!==void 0&&{leaseId:c.leaseId},...c.unlockTime!==void 0&&{unlockTime:c.unlockTime},...c.lockTime!==void 0&&{lockTime:c.lockTime},...c.duration!==void 0&&{duration:c.duration},...c.details!==void 0&&{details:c.details},previousHash:c.previousHash,chainHash:p,signer:c.signer,signerId:c.signerId,...b.cert!==void 0&&{cert:b.cert},sig:K};await Be(P),t(P)}catch(s){r(s)}}).catch(()=>{}),n}async function Ne(){let e=await G(),t=[],r=0;for(let n of e){let s={kmsVersion:n.kmsVersion,seqNum:n.seqNum,timestamp:n.timestamp,op:n.op,kid:n.kid,requestId:n.requestId,userId:n.userId,origin:n.origin,leaseId:n.leaseId,unlockTime:n.unlockTime,lockTime:n.lockTime,duration:n.duration,details:n.details,previousHash:n.previousHash,signer:n.signer,signerId:n.signerId},a=JSON.stringify(s),u=new TextEncoder().encode(n.previousHash+a),i=await crypto.subtle.digest("SHA-256",u);f(i)!==n.chainHash&&t.push(`Chain hash mismatch at seq ${n.seqNum}`),r+=1}return{valid:t.length===0,verified:r,errors:t}}async function Je(){let e=await C("audit-user");if(!e||!e.publicKeyRaw)throw new Error("UAK not initialized");return{publicKey:f(e.publicKeyRaw)}}function _e(){b=null,ve=Promise.resolve()}function oe(e){if(e instanceof Error)return e.message;if(typeof e=="string")return e;if(typeof e=="object"&&e!==null&&"message"in e&&typeof e.message=="string")return e.message;try{return String(e)}catch{return"Unknown error"}}var m=class extends Error{constructor(r,n,s,a){super(`RPC ${r}: Invalid ${n} - expected ${s}, got ${typeof a}`);this.method=r;this.param=n;this.expected=s;this.received=a;this.name="RPCValidationError"}};function h(e,t){if(typeof t!="object"||t===null)throw new m(e,"params","object",t);return t}function g(e,t,r){if(typeof r!="string")throw new m(e,t,"string",r);return r}function M(e,t,r){if(r!==void 0)return g(e,t,r)}function ue(e,t,r){if(typeof r!="number")throw new m(e,t,"number",r);return r}function It(e,t,r){if(typeof r!="boolean")throw new m(e,t,"boolean",r);return r}function ze(e,t,r){if(r!==void 0)return It(e,t,r)}function Pe(e,t,r){if(r instanceof ArrayBuffer)return r;if(r instanceof Uint8Array){let n=new ArrayBuffer(r.byteLength);return new Uint8Array(n).set(r),n}throw new m(e,t,"ArrayBuffer or Uint8Array",r)}function Ee(e,t,r){if(r!==void 0){if(r instanceof Uint8Array)return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);throw new m(e,t,"ArrayBuffer or Uint8Array",r)}}function U(e,t){if(typeof t!="object"||t===null)throw new m(e,"credentials","AuthCredentials object",t);let r=t;if(typeof r.method!="string")throw new m(e,"credentials.method","string",r.method);if(typeof r.userId!="string")throw new m(e,"credentials.userId","string",r.userId);switch(r.method){case"passphrase":if(typeof r.passphrase!="string")throw new m(e,"credentials.passphrase","string",r.passphrase);return{method:"passphrase",passphrase:r.passphrase,userId:r.userId};case"passkey-prf":if(!(r.prfOutput instanceof ArrayBuffer))throw new m(e,"credentials.prfOutput","ArrayBuffer",r.prfOutput);return{method:"passkey-prf",prfOutput:r.prfOutput,userId:r.userId};case"passkey-gate":return{method:"passkey-gate",userId:r.userId};default:throw new m(e,"credentials.method","passphrase | passkey-prf | passkey-gate",r.method)}}function vt(e,t){if(typeof t!="object"||t===null)throw new m(e,"payload","VAPIDPayload object",t);let r=t;return{aud:g(e,"payload.aud",r.aud),sub:g(e,"payload.sub",r.sub),exp:ue(e,"payload.exp",r.exp),jti:g(e,"payload.jti",r.jti)}}function Qe(e){let t=h("setupPassphrase",e),r=Ee("setupPassphrase","existingMS",t.existingMS);return{userId:g("setupPassphrase","userId",t.userId),passphrase:g("setupPassphrase","passphrase",t.passphrase),...r!==void 0&&{existingMS:r}}}function Xe(e){let t=h("setupPasskeyPRF",e);if(!t.credentialId)throw new Error("credentialId required");let r=M("setupPasskeyPRF","rpId",t.rpId),n=Ee("setupPasskeyPRF","existingMS",t.existingMS);return{userId:g("setupPasskeyPRF","userId",t.userId),credentialId:Pe("setupPasskeyPRF","credentialId",t.credentialId),prfOutput:Pe("setupPasskeyPRF","prfOutput",t.prfOutput),...r!==void 0&&{rpId:r},...n!==void 0&&{existingMS:n}}}function Ye(e){let t=h("setupPasskeyGate",e),r=M("setupPasskeyGate","rpId",t.rpId),n=Ee("setupPasskeyGate","existingMS",t.existingMS);return{userId:g("setupPasskeyGate","userId",t.userId),credentialId:Pe("setupPasskeyGate","credentialId",t.credentialId),...r!==void 0&&{rpId:r},...n!==void 0&&{existingMS:n}}}function Ze(e){let t=h("addEnrollment",e),r=g("addEnrollment","method",t.method);if(r!=="passphrase"&&r!=="passkey-prf"&&r!=="passkey-gate")throw new m("addEnrollment","method","passphrase | passkey-prf | passkey-gate",r);return{userId:g("addEnrollment","userId",t.userId),method:r,credentials:U("addEnrollment",t.credentials),newCredentials:t.newCredentials}}function et(e){let t=h("generateVAPID",e);return{credentials:U("generateVAPID",t.credentials)}}function tt(e){let t=h("regenerateVAPID",e);return{credentials:U("regenerateVAPID",t.credentials)}}function rt(e){let t=h("signJWT",e);return{kid:g("signJWT","kid",t.kid),payload:vt("signJWT",t.payload),credentials:U("signJWT",t.credentials)}}function nt(e){let t=h("createLease",e),r={userId:g("createLease","userId",t.userId),ttlHours:ue("createLease","ttlHours",t.ttlHours),credentials:U("createLease",t.credentials)},n=ze("createLease","autoExtend",t.autoExtend);return n!==void 0&&(r.autoExtend=n),r}function st(e){let t=h("extendLeases",e);if(!Array.isArray(t.leaseIds))throw new Error(`RPC extendLeases: Invalid leaseIds - expected array, got ${typeof t.leaseIds}`);if(t.leaseIds.length===0)throw new Error("RPC extendLeases: leaseIds array cannot be empty");let n={leaseIds:t.leaseIds.map((a,u)=>{if(typeof a!="string"||a.length===0)throw new Error(`RPC extendLeases: Invalid leaseId at index ${u} - expected non-empty string`);return a}),userId:g("extendLeases","userId",t.userId)},s=ze("extendLeases","requestAuth",t.requestAuth);return s!==void 0&&(n.requestAuth=s),t.credentials!==void 0&&(n.credentials=U("extendLeases",t.credentials)),n}function at(e){let t=h("issueVAPIDJWT",e),r=M("issueVAPIDJWT","kid",t.kid),n=M("issueVAPIDJWT","jti",t.jti),s=t.exp!==void 0?ue("issueVAPIDJWT","exp",t.exp):void 0;return{leaseId:g("issueVAPIDJWT","leaseId",t.leaseId),...r!==void 0&&{kid:r},...n!==void 0&&{jti:n},...s!==void 0&&{exp:s}}}function it(e){let t=h("issueVAPIDJWTs",e),r=M("issueVAPIDJWTs","kid",t.kid);return{leaseId:g("issueVAPIDJWTs","leaseId",t.leaseId),count:ue("issueVAPIDJWTs","count",t.count),...r!==void 0&&{kid:r}}}function ot(e){if(e==null)return{};let t=h("isSetup",e),r=M("isSetup","userId",t.userId);return r!==void 0?{userId:r}:{}}function ut(e){if(e==null)return{};let t=h("getEnrollments",e),r=M("getEnrollments","userId",t.userId);return r!==void 0?{userId:r}:{}}function ct(e){let t=h("getPublicKey",e);return{kid:g("getPublicKey","kid",t.kid)}}function dt(e){let t=h("getUserLeases",e);return{userId:g("getUserLeases","userId",t.userId)}}function lt(e){let t=h("verifyLease",e),r={leaseId:g("verifyLease","leaseId",t.leaseId)};if("deleteIfInvalid"in t){if(typeof t.deleteIfInvalid!="boolean")throw new Error("verifyLease: deleteIfInvalid must be a boolean");r.deleteIfInvalid=t.deleteIfInvalid}return r}function pt(e){let t=h("removeEnrollment",e);return{enrollmentId:g("removeEnrollment","enrollmentId",t.enrollmentId),credentials:U("removeEnrollment",t.credentials)}}var Pt=["fcm.googleapis.com","web.push.apple.com","updates.push.services.mozilla.com","notify.windows.com"];function Et(e,t){if(typeof t!="object"||t===null)throw new m(e,"subscription","object",t);let r=t,n=g(e,"subscription.endpoint",r.endpoint);if(!n.startsWith("https://"))throw new Error(`${e}: subscription.endpoint must use HTTPS`);let s;try{s=new URL(n)}catch{throw new Error(`${e}: subscription.endpoint is not a valid URL`)}if(!Pt.some(p=>s.hostname===p||s.hostname.endsWith(`.${p}`)))throw new Error(`${e}: subscription.endpoint must be from a known push service (FCM, APNs, Mozilla Push, WNS). Got: ${s.hostname}`);let u=r.expirationTime;if(u!==null&&typeof u!="number")throw new m(e,"subscription.expirationTime","number or null",u);if(typeof r.keys!="object"||r.keys===null)throw new m(e,"subscription.keys","object",r.keys);let i=r.keys,c=g(e,"subscription.keys.p256dh",i.p256dh),l=g(e,"subscription.keys.auth",i.auth);if(c.length===0)throw new Error(`${e}: subscription.keys.p256dh must be non-empty`);if(l.length===0)throw new Error(`${e}: subscription.keys.auth must be non-empty`);let o=g(e,"subscription.eid",r.eid);if(o.length===0)throw new Error(`${e}: subscription.eid must be non-empty`);let d=r.createdAt;if(typeof d!="number")throw new m(e,"subscription.createdAt","number",d);return{endpoint:n,expirationTime:u,keys:{p256dh:c,auth:l},eid:o,createdAt:d}}function yt(e){let t=h("setPushSubscription",e);return{subscription:Et("setPushSubscription",t.subscription)}}function St(e){if(typeof e!="object"||e===null)return!1;let t=e;return typeof t.tokensIssued=="number"&&typeof t.lastResetAt=="number"}function ft(e){return St(e)?e:{tokensIssued:0,lastResetAt:Date.now()}}var xe=new Map;async function Dt(e,t){let r=await crypto.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:t,info:new TextEncoder().encode("ATS/KMS/SessionKEK/v1")},r,{name:"AES-GCM",length:256},!1,["wrapKey","unwrapKey"])}self.addEventListener("message",e=>{(async()=>{let t=e.data,r=await Ct(t);self.postMessage(r)})().catch(t=>{console.error("[KMS Worker] Message handling failed:",t);let r=e.data;self.postMessage({id:r?.id||"unknown",error:t instanceof Error?t.message:"Unknown error"})})});async function Ct(e){let{id:t,method:r,params:n}=e;try{let s;switch(r){case"setupPassphrase":s=await Rt(Qe(n),t);break;case"setupPasskeyPRF":s=await Vt(Xe(n),t);break;case"setupPasskeyGate":s=await Tt(Ye(n),t);break;case"addEnrollment":s=await Lt(Ze(n),t);break;case"generateVAPID":s=await Mt(et(n),t);break;case"regenerateVAPID":s=await Ut(tt(n),t);break;case"signJWT":s=await Bt(rt(n),t);break;case"createLease":s=await jt(nt(n),t);break;case"extendLeases":s=await Ot(st(n),t);break;case"issueVAPIDJWT":s=await wt(at(n),t);break;case"issueVAPIDJWTs":s=await Wt(it(n),t);break;case"isSetup":s=await qt(ot(n));break;case"getEnrollments":s=await $t(ut(n));break;case"verifyAuditChain":s=await Gt();break;case"getAuditLog":s=await Ft();break;case"getPublicKey":s=await Ht(ct(n));break;case"getAuditPublicKey":s=await Nt();break;case"getUserLeases":s=await Jt(dt(n));break;case"verifyLease":s=await _t(lt(n));break;case"getVAPIDKid":s=await zt();break;case"resetKMS":s=await Zt();break;case"removeEnrollment":s=await er(pt(n),t);break;case"setPushSubscription":s=await Qt(yt(n));break;case"removePushSubscription":s=await Xt();break;case"getPushSubscription":s=await Yt();break;default:throw new Error(`Unknown RPC method: ${r}`)}return{id:t,result:s}}catch(s){return{id:t,error:oe(s)}}}async function Rt(e,t){let{userId:r,passphrase:n,existingMS:s}=e;if(!n||n.length<8)throw new Error("Passphrase must be at least 8 characters");let a=await ge(r,n,s);if(!a.success)throw new Error(a.error);let u=await _(a.ms);await S(u);let i=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"]);if(!("privateKey"in i)||!("publicKey"in i))throw new Error("Failed to generate ECDSA keypair");let c=i,l=await crypto.subtle.exportKey("raw",c.publicKey),o=O(new Uint8Array(l)),d=await W(o);return await D(c.privateKey,u,d,{name:"ECDSA",namedCurve:"P-256"},["sign"],{alg:"ES256",purpose:"vapid",publicKeyRaw:l}),a.ms.fill(0),await v({op:"setup-passphrase",kid:"",requestId:t,userId:r,details:{method:"passphrase",vapidKid:d}}),{success:!0,enrollmentId:"enrollment:passphrase:v2",vapidPublicKey:f(l),vapidKid:d}}async function Vt(e,t){let{userId:r,credentialId:n,prfOutput:s,rpId:a="",existingMS:u}=e;if(!n||n.byteLength===0)throw new Error("credentialId required");if(!s||s.byteLength!==32)throw new Error("prfOutput must be 32 bytes");let i=await me(r,n,s,u,a);if(!i.success)throw new Error(i.error);let c=await _(i.ms);await S(c);let l=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"]);if(!("privateKey"in l)||!("publicKey"in l))throw new Error("Failed to generate ECDSA keypair");let o=l,d=await crypto.subtle.exportKey("raw",o.publicKey),p=O(new Uint8Array(d)),y=await W(p);return await D(o.privateKey,c,y,{name:"ECDSA",namedCurve:"P-256"},["sign"],{alg:"ES256",purpose:"vapid",publicKeyRaw:d}),i.ms.fill(0),await v({op:"setup-passkey-prf",kid:"",requestId:t,userId:r,details:{method:"passkey-prf",credentialId:f(n),vapidKid:y}}),{success:!0,enrollmentId:"enrollment:passkey-prf:v2",vapidPublicKey:f(d),vapidKid:y}}async function Tt(e,t){let{userId:r,credentialId:n,rpId:s="",existingMS:a}=e;if(!n||n.byteLength===0)throw new Error("credentialId required");let u=await ke(r,n,a,s);if(!u.success)throw new Error(u.error);let i=await _(u.ms);await S(i);let c=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"]);if(!("privateKey"in c)||!("publicKey"in c))throw new Error("Failed to generate ECDSA keypair");let l=c,o=await crypto.subtle.exportKey("raw",l.publicKey),d=O(new Uint8Array(o)),p=await W(d);return await D(l.privateKey,i,p,{name:"ECDSA",namedCurve:"P-256"},["sign"],{alg:"ES256",purpose:"vapid",publicKeyRaw:o}),u.ms.fill(0),await v({op:"setup-passkey-gate",kid:"",requestId:t,userId:r,details:{method:"passkey-gate",credentialId:f(n),vapidKid:p}}),{success:!0,enrollmentId:"enrollment:passkey-gate:v2",vapidPublicKey:f(o),vapidKid:p}}async function Lt(e,t){let{userId:r,method:n,credentials:s,newCredentials:a}=e;function u(o,d){if(typeof d!="object"||d===null)throw new Error(`newCredentials must be an object for ${o}`);return d}let i=u(n,a);await R(s,async(o,d)=>(await S(o),!0));let c;if(s.method==="passphrase"){let o=await he(r,s.passphrase);if(!o.success)throw new Error(o.error);c=o.ms}else if(s.method==="passkey-prf"){let o=await Ae(r,s.prfOutput);if(!o.success)throw new Error(o.error);c=o.ms}else if(s.method==="passkey-gate"){let o=await be(r);if(!o.success)throw new Error(o.error);c=o.ms}else throw new Error("Invalid credentials method");let l;if(n==="passphrase"){if(typeof i.passphrase!="string")throw new Error("passphrase must be a string");l=await ge(r,i.passphrase,c)}else if(n==="passkey-prf"){if(!(i.credentialId instanceof ArrayBuffer))throw new Error("credentialId must be an ArrayBuffer");if(!(i.prfOutput instanceof ArrayBuffer))throw new Error("prfOutput must be an ArrayBuffer");let o=typeof i.rpId=="string"?i.rpId:"";l=await me(r,i.credentialId,i.prfOutput,c,o)}else if(n==="passkey-gate"){if(!(i.credentialId instanceof ArrayBuffer))throw new Error("credentialId must be an ArrayBuffer");let o=typeof i.rpId=="string"?i.rpId:"";l=await ke(r,i.credentialId,c,o)}else{let o=n;throw new Error(`Unknown enrollment method: ${String(o)}`)}if(c.fill(0),!l.success)throw new Error(l.error);return await v({op:"add-enrollment",kid:"",requestId:t,userId:s.userId,details:{method:n,action:"add-enrollment"}}),{success:!0,enrollmentId:`enrollment:${n}:v2`}}async function Mt(e,t){let{credentials:r}=e,n=await R(r,async(s,a)=>{await S(s);let u=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"]);if(!("privateKey"in u)||!("publicKey"in u))throw new Error("Failed to generate ECDSA keypair");let i=u,c=await crypto.subtle.exportKey("raw",i.publicKey),l=O(new Uint8Array(c)),o=await W(l);return await D(i.privateKey,s,o,{name:"ECDSA",namedCurve:"P-256"},["sign"],{alg:"ES256",purpose:"vapid",publicKeyRaw:c}),{kid:o,publicKey:f(c)}});return await v({op:"generate",kid:n.result.kid,requestId:t,userId:r.userId,unlockTime:n.unlockTime,lockTime:n.lockTime,duration:n.duration,details:{algorithm:"ECDSA",curve:"P-256",purpose:"vapid"}}),n.result}async function Ut(e,t){let{credentials:r}=e,n=await R(r,async(s,a)=>{await S(s);let i=(await E()).filter(y=>y.purpose==="vapid");for(let y of i)await Me(y.kid);let c=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"]);if(!("privateKey"in c)||!("publicKey"in c))throw new Error("Failed to generate ECDSA keypair");let l=c,o=await crypto.subtle.exportKey("raw",l.publicKey),d=O(new Uint8Array(o)),p=await W(d);return await D(l.privateKey,s,p,{name:"ECDSA",namedCurve:"P-256"},["sign"],{alg:"ES256",purpose:"vapid",publicKeyRaw:o}),{kid:p,publicKey:f(o),oldKids:i.map(y=>y.kid)}});return await v({op:"regenerate-vapid",kid:n.result.kid,requestId:t,userId:r.userId,unlockTime:n.unlockTime,lockTime:n.lockTime,duration:n.duration,details:{algorithm:"ECDSA",curve:"P-256",purpose:"vapid",oldKids:n.result.oldKids,deletedCount:n.result.oldKids.length}}),{kid:n.result.kid,publicKey:n.result.publicKey}}async function Bt(e,t){let{kid:r,payload:n,credentials:s}=e;if(!n.aud||!n.sub||!n.exp)throw new Error("JWT payload must include aud, sub, and exp");let a=Math.floor(Date.now()/1e3);if(n.exp<=a)throw new Error("JWT exp must be in the future");if(n.exp>a+86400)throw new Error("JWT exp must be <= 24 hours (RFC 8292)");let u=await R(s,async(i,c)=>{await S(i);let l=await Le(r,i,{name:"ECDSA",namedCurve:"P-256"},["sign"]),o={typ:"JWT",alg:"ES256",kid:r},d=f(new TextEncoder().encode(JSON.stringify(o)).buffer),p=f(new TextEncoder().encode(JSON.stringify(n)).buffer),y=new TextEncoder().encode(`${d}.${p}`),w=await crypto.subtle.sign({name:"ECDSA",hash:"SHA-256"},l,y),K=f(w);return{jwt:`${d}.${p}.${K}`}});return await v({op:"sign",kid:r,requestId:t,userId:s.userId,unlockTime:u.unlockTime,lockTime:u.lockTime,duration:u.duration,details:{algorithm:"ES256",aud:n.aud,exp:n.exp,jti:n.jti}}),u.result}async function jt(e,t){let{userId:r,ttlHours:n,credentials:s,autoExtend:a}=e;if(n<=0||n>720)throw new Error("ttlHours must be between 0 and 720 (30 days)");let i=(await E()).filter(I=>I.purpose==="vapid");if(i.length===0)throw new Error("No VAPID key found. VAPID key should have been generated during setup.");i.sort((I,A)=>A.createdAt-I.createdAt);let c=i[0];if(!c)throw new Error("VAPID key record not found after filtering");let l=c.kid,o=`lease-${crypto.randomUUID()}`,d=crypto.getRandomValues(new Uint8Array(32)),p=Date.now(),y=p+n*3600*1e3,w=await R(s,async(I,A)=>{await S(I);let{delegationCert:V}=await Ge(o,y),B=await Dt(A,d),j=await C(l);if(!j)throw new Error(`No wrapped key with id: ${l}`);let Q=new Uint8Array(j.iv),X=j.aad,ce=await crypto.subtle.unwrapKey("pkcs8",j.wrappedKey,I,{name:"AES-GCM",iv:Q,additionalData:X},{name:"ECDSA",namedCurve:"P-256"},!0,["sign"]),Y=crypto.getRandomValues(new Uint8Array(12));return{wrappedLeaseKey:await crypto.subtle.wrapKey("pkcs8",ce,B,{name:"AES-GCM",iv:Y}),iv:Y,sessionKEK:B,lakDelegationCert:V}});await x(`sessionkek:${o}`,w.result.sessionKEK),xe.set(o,w.result.sessionKEK);let K={tokensPerHour:100,sendsPerMinute:10,burstSends:20,sendsPerMinutePerEid:5},P={leaseId:o,userId:r,ttlHours:n,createdAt:p,exp:y,autoExtend:a??!0,quotas:K,wrappedLeaseKey:w.result.wrappedLeaseKey,wrappedLeaseKeyIV:w.result.iv.buffer.slice(w.result.iv.byteOffset,w.result.iv.byteOffset+w.result.iv.byteLength),leaseSalt:d.buffer.slice(d.byteOffset,d.byteOffset+d.byteLength),kid:l,lakDelegationCert:w.result.lakDelegationCert};return await pe(P),await x(`quota:${o}`,{leaseId:o,tokensIssued:0,lastResetAt:p,perEndpoint:{}}),await v({op:"create-lease",kid:l,requestId:t,userId:r,details:{action:"create-lease",leaseId:o,userId:r,ttlHours:n,autoExtend:P.autoExtend}}),{leaseId:o,exp:y,quotas:K,autoExtend:P.autoExtend??!0}}async function Ot(e,t){let{leaseIds:r,credentials:n,requestAuth:s}=e,a=[],u=0,i=0,c=0,l=!1;if(n)try{await R(n,async(o,d)=>(l=!0,Promise.resolve()))}catch(o){for(let d of r){let p=await N(d);p&&p.autoExtend===!1&&(a.push({leaseId:d,status:"skipped",reason:`Authentication failed: ${oe(o)}`}),i++)}if(i===r.length)return{results:a,extended:u,skipped:i,failed:c}}for(let o of r)try{let d=await N(o);if(!d){a.push({leaseId:o,status:"skipped",reason:`Lease not found: ${o}`}),i++;continue}if(d.autoExtend===!1&&!s){a.push({leaseId:o,status:"skipped",reason:"Lease has autoExtend=false and authentication was not requested"}),i++;continue}if(d.autoExtend===!1&&s&&!l){a.push({leaseId:o,status:"skipped",reason:"Authentication required but credentials not valid"}),i++;continue}let y=(await E()).filter(V=>V.purpose==="vapid");if(y.length===0){a.push({leaseId:o,status:"skipped",reason:"No VAPID key found"}),i++;continue}y.sort((V,B)=>B.createdAt-V.createdAt);let K=y[0].kid;if(d.kid!==K){a.push({leaseId:o,status:"skipped",reason:`Lease is for different VAPID key (lease kid: ${d.kid}, current kid: ${K})`}),i++;continue}let P=Date.now(),I=P+30*24*60*60*1e3,A={...d,exp:I,createdAt:P};await pe(A),await v({op:"extend-lease",kid:A.kid,requestId:t,userId:A.userId,details:{action:"extend-lease",leaseId:A.leaseId,userId:A.userId,newExp:I,autoExtend:A.autoExtend}}),a.push({leaseId:o,status:"extended",result:{leaseId:A.leaseId,exp:A.exp,iat:A.createdAt,kid:A.kid,autoExtend:A.autoExtend??!1}}),u++}catch(d){a.push({leaseId:o,status:"skipped",reason:`Error extending lease: ${oe(d)}`}),c++}return{results:a,extended:u,skipped:i,failed:c}}async function wt(e,t){let{leaseId:r}=e,{kid:n}=e;if(!n){let F=(await E()).filter(kt=>kt.purpose==="vapid");if(F.length===0)throw new Error("No VAPID key found. Create a lease first to auto-generate one.");if(F.length>1)throw new Error("Multiple VAPID keys found. Please specify kid explicitly.");let De=F[0];if(!De)throw new Error("No VAPID key found after filtering");n=De.kid}let s=await N(r);if(!s)throw new Error(`Lease not found: ${r}`);if(Date.now()>=s.exp)throw new Error("Lease expired");let u=(await E()).filter(T=>T.purpose==="vapid");if(u.length===0)throw new Error("No VAPID key available");u.sort((T,F)=>F.createdAt-T.createdAt);let i=u[0]?.kid;if(!i)throw new Error("Failed to determine current VAPID key");if(s.kid!==i)throw new Error("Lease invalidated by VAPID key rotation (wrong-key)");await Fe(r,s.lakDelegationCert);let c=await fe();if(!c)throw new Error("No push subscription found. Call setPushSubscription() first.");let l=await k(`quota:${r}`),o=ft(l),d=Date.now()-3600*1e3;if(o.lastResetAt<d&&(o.tokensIssued=0,o.lastResetAt=Date.now()),o.tokensIssued>=s.quotas.tokensPerHour)throw new Error("Quota exceeded: tokens per hour");o.tokensIssued++,await x(`quota:${r}`,o);let p=e.jti??crypto.randomUUID(),y=e.exp??Math.floor(Date.now()/1e3)+900,w=new URL(c.endpoint),K=`${w.protocol}//${w.host}`,P={aud:K,sub:"mailto:kms@example.com",exp:y,jti:p,uid:s.userId,eid:c.eid},I=xe.get(r);if(!I){let T=await k(`sessionkek:${r}`);if(!T)throw new Error(`SessionKEK not found for lease: ${r}`);I=T,xe.set(r,I)}let A=s.wrappedLeaseKey,V=new Uint8Array(s.wrappedLeaseKeyIV),B=await crypto.subtle.unwrapKey("pkcs8",A,I,{name:"AES-GCM",iv:V},{name:"ECDSA",namedCurve:"P-256"},!1,["sign"]),j={typ:"JWT",alg:"ES256",kid:s.kid},Q=f(new TextEncoder().encode(JSON.stringify(j)).buffer),X=f(new TextEncoder().encode(JSON.stringify(P)).buffer),ce=new TextEncoder().encode(`${Q}.${X}`),Y=await crypto.subtle.sign({name:"ECDSA",hash:"SHA-256"},B,ce),Se=f(Y),gt=`${Q}.${X}.${Se}`,mt=await v({op:"sign",kid:s.kid,requestId:t,userId:s.userId,leaseId:r,details:{action:"issue-lease-jwt",jti:p,aud:K,eid:c.eid}});return{jwt:gt,jti:p,exp:y,auditEntry:mt}}async function Wt(e,t){let{leaseId:r,count:n,kid:s}=e;if(!Number.isInteger(n)||n<1||n>10)throw new Error("count must be an integer between 1 and 10");let a=900,u=Math.floor(a*.6),i=Math.floor(Date.now()/1e3),c=[];for(let l=0;l<n;l++){let o=crypto.randomUUID(),d=i+a+l*u,p=await wt({leaseId:r,...s!==void 0&&{kid:s},jti:o,exp:d},`${t}-${l}`);c.push(p)}return c}async function qt(e){let t=e?.userId??"default",r=await qe(t),n=[];await Ke(t)&&n.push("passphrase"),await Ie(t)&&n.push("passkey");let s;return r&&e?.userId&&(s=await ye(e.userId)),{isSetup:r,methods:n,...s!==void 0&&{leases:s}}}async function $t(e){let t=e?.userId??"default",r=[];if(await Ke(t)&&r.push("enrollment:passphrase:v2"),await Ie(t)){let n=await k(`enrollment:passkey-prf:v2:${t}`),s=await k(`enrollment:passkey-gate:v2:${t}`);n&&r.push("enrollment:passkey-prf:v2"),s&&r.push("enrollment:passkey-gate:v2")}return{enrollments:r}}async function Gt(){return await Ne()}async function Ft(){return{entries:await G()}}async function Ht(e){let{kid:t}=e,r=await C(t);if(!r||!r.publicKeyRaw)throw new Error(`Public key not found for kid: ${t}`);return{publicKey:f(r.publicKeyRaw)}}async function Nt(){return await Je()}async function Jt(e){let{userId:t}=e;return{leases:await ye(t)}}async function _t(e){let{leaseId:t,deleteIfInvalid:r=!1}=e,n=await N(t);if(!n)return{leaseId:t,valid:!1,reason:"not-found",kid:""};if(Date.now()>=n.exp)return r&&await J(t),{leaseId:t,valid:!1,reason:"expired",kid:n.kid};let a=(await E()).filter(c=>c.purpose==="vapid");if(a.length===0)return r&&await J(t),{leaseId:t,valid:!1,reason:"no-vapid-key",kid:n.kid};a.sort((c,l)=>l.createdAt-c.createdAt);let u=a[0];if(!u)return r&&await J(t),{leaseId:t,valid:!1,reason:"no-vapid-key",kid:n.kid};let i=u.kid;return n.kid!==i?(r&&await J(t),{leaseId:t,valid:!1,reason:"wrong-key",kid:n.kid}):{leaseId:t,valid:!0,kid:n.kid}}async function zt(){let t=(await E()).filter(n=>n.purpose==="vapid");if(t.length===0)throw new Error("No VAPID key found");if(t.length>1)throw new Error("Multiple VAPID keys found. Please use getPublicKey(kid) with explicit kid.");let r=t[0];if(!r)throw new Error("No VAPID key found after filtering");return{kid:r.kid}}async function Qt(e){return await Oe(e.subscription),{success:!0}}async function Xt(){return await We(),{success:!0}}async function Yt(){return{subscription:await fe()}}async function Zt(){Te();let e=indexedDB.deleteDatabase("kms-v2");return await new Promise((t,r)=>{e.onsuccess=()=>t(),e.onerror=()=>r(new Error(e.error?.message??"Failed to delete database"))}),await te(),_e(),{success:!0}}async function er(e,t){let{enrollmentId:r,credentials:n}=e;return await R(n,async(s,a)=>(await S(s),!0)),await Ue(r),await v({op:"reset",kid:"",requestId:t,userId:n.userId,details:{action:"remove-enrollment",enrollmentId:r}}),{success:!0}}(async()=>{try{await te(),await $e(),await He(),(await G()).length===0&&await v({op:"kms-init",kid:"",requestId:`init-${Date.now()}`,userId:"system",details:{kmsVersion:"v2.0.0",timestamp:new Date().toISOString(),note:"KMS worker initialized, KIAK generated"}})}catch(e){console.error("[KMS Worker] Initialization failed:",e)}})();export{Ct as handleMessage};
