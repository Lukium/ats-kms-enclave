function g(e){let t=new Uint8Array(e),r=Array.from(t,s=>String.fromCharCode(s)).join("");return btoa(r).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/g,"")}function x(e){let t=e.replace(/-/g,"+").replace(/_/g,"/"),r=t.length%4;r&&(t+="=".repeat(4-r));let n=atob(t),s=new Uint8Array(n.length);for(let a=0;a<n.length;a++)s[a]=n.charCodeAt(a);return s.buffer}function N(e){if(e.length!==65||e[0]!==4)throw new Error("Invalid uncompressed P-256 public key");let t=g(e.slice(1,33).buffer),r=g(e.slice(33).buffer);return{kty:"EC",crv:"P-256",x:t,y:r}}async function J(e){let t={crv:e.crv,kty:e.kty,x:e.x,y:e.y},r=JSON.stringify(t),n=await crypto.subtle.digest("SHA-256",new TextEncoder().encode(r));return g(n)}function Ue(e){return"{"+Object.keys(e).sort().map(n=>[n,e[n]]).map(([n,s])=>`"${String(n)}":${JSON.stringify(s)}`).join(",")+"}"}function oe(e){let t={kmsVersion:e.kmsVersion,method:e.method,algVersion:e.algVersion,purpose:e.purpose};e.credentialId&&(t.credentialId=g(e.credentialId));let r=Ue(t);return new TextEncoder().encode(r).buffer}function ue(e){let t={kmsVersion:e.kmsVersion,kid:e.kid,alg:e.alg,purpose:e.purpose,createdAt:e.createdAt,keyType:e.keyType},r=Ue(t);return new TextEncoder().encode(r).buffer}async function he(e){let t=await crypto.subtle.exportKey("raw",e),r=await crypto.subtle.importKey("raw",t,{name:"HMAC",hash:"SHA-256"},!1,["sign"]),n=new TextEncoder().encode("ATS/KMS/KCV/v2");return await crypto.subtle.sign("HMAC",r,n)}function Le(e,t){return Tt(e,t)}function Tt(e,t){let r=new Uint8Array(e),n=new Uint8Array(t);if(r.length!==n.length)return!1;let s=0;for(let a=0;a<r.length;a++)s|=r[a]^n[a];return s===0}async function Z(e){return await crypto.subtle.digest("SHA-256",new TextEncoder().encode(e))}async function Me(e={min:150,max:300,mid:220}){let t=await crypto.subtle.importKey("raw",new TextEncoder().encode("calibration"),"PBKDF2",!1,["deriveBits"]),r=crypto.getRandomValues(new Uint8Array(16)),n=1e5,s=performance.now();await crypto.subtle.deriveBits({name:"PBKDF2",hash:"SHA-256",salt:r,iterations:n},t,256);let i=performance.now()-s,o=Math.round(n*e.mid/i);return o=Math.min(Math.max(o,5e4),2e6),{iterations:o,measuredMs:i}}var Vt="kms-v2",Ut=1,q=null;async function de(){return new Promise((e,t)=>{let r=indexedDB.open(Vt,Ut);r.onerror=()=>{t(new Error("Failed to open IndexedDB"))},r.onsuccess=()=>{q=r.result,e()},r.onupgradeneeded=n=>{let s=n.target.result;if(s.objectStoreNames.contains("config")||s.createObjectStore("config",{keyPath:"method"}),!s.objectStoreNames.contains("keys")){let a=s.createObjectStore("keys",{keyPath:"kid"});a.createIndex("by-purpose","purpose",{unique:!1}),a.createIndex("by-createdAt","createdAt",{unique:!1})}if(!s.objectStoreNames.contains("leases")){let a=s.createObjectStore("leases",{keyPath:"leaseId"});a.createIndex("by-userId","userId",{unique:!1}),a.createIndex("by-exp","exp",{unique:!1})}if(!s.objectStoreNames.contains("audit")){let a=s.createObjectStore("audit",{autoIncrement:!0});a.createIndex("by-seqNum","seqNum",{unique:!0}),a.createIndex("by-timestamp","timestamp",{unique:!1}),a.createIndex("by-op","op",{unique:!1}),a.createIndex("by-kid","kid",{unique:!1})}s.objectStoreNames.contains("meta")||s.createObjectStore("meta",{keyPath:"key"})}})}async function _(){if(q||await de(),!q)throw new Error("Database not initialized");return q}function Be(){q&&(q.close(),q=null)}async function ce(e,t){let r=await _();return new Promise((n,s)=>{let o=r.transaction(e,"readonly").objectStore(e).get(t);o.onsuccess=()=>{n(o.result)},o.onerror=()=>{s(new Error(`Failed to get from ${e}`))}})}async function z(e,t){let r=await _();return new Promise((n,s)=>{let o=r.transaction(e,"readwrite").objectStore(e).put(t);o.onsuccess=()=>{n()},o.onerror=()=>{s(new Error(`Failed to put to ${e}`))}})}async function ke(e,t){let r=await _();return new Promise((n,s)=>{let o=r.transaction(e,"readwrite").objectStore(e).delete(t);o.onsuccess=()=>{n()},o.onerror=()=>{s(new Error(`Failed to delete from ${e}`))}})}async function Lt(e){let t=await _();return new Promise((r,n)=>{let i=t.transaction(e,"readonly").objectStore(e).getAll();i.onsuccess=()=>{r(i.result)},i.onerror=()=>{n(new Error(`Failed to getAll from ${e}`))}})}async function M(e,t,r,n=e.algorithm,s=e.usages,a={alg:"unknown",purpose:"unknown"}){let i=crypto.getRandomValues(new Uint8Array(12)),o=Date.now(),u=ue({kmsVersion:2,kid:r,alg:a.alg,purpose:a.purpose,createdAt:o,keyType:Array.isArray(s)?s.join(","):String(s)}),d=e.type==="private"?"pkcs8":"raw",c=await crypto.subtle.exportKey(d,e),l=await crypto.subtle.encrypt({name:"AES-GCM",iv:i,additionalData:u},t,c),p={kid:r,kmsVersion:2,wrappedKey:l,iv:i.buffer.slice(i.byteOffset,i.byteOffset+i.byteLength),aad:u,...a.publicKeyRaw!==void 0&&{publicKeyRaw:a.publicKeyRaw},alg:a.alg,purpose:a.purpose,createdAt:o};await z("keys",p)}async function He(e,t,r,n=[]){let s=await ce("keys",e);if(!s)throw new Error(`No wrapped key with id: ${e}`);let a=new Uint8Array(s.iv),i=s.aad,o=await crypto.subtle.decrypt({name:"AES-GCM",iv:a,additionalData:i},t,s.wrappedKey),u=typeof r=="string"?r:r.name,c=u==="ECDSA"||u==="ECDH"||u==="Ed25519"||u.startsWith("RSA")?"pkcs8":"raw";return await crypto.subtle.importKey(c,o,r,!1,n)}async function H(e){return await ce("keys",e)??null}async function V(){return Lt("keys")}async function Oe(e){await ke("keys",e)}async function C(e){let t=await ce("meta",e);return t?t.value:null}async function U(e,t){await z("meta",{key:e,value:t})}async function je(e){await ke("meta",e)}async function qe(e){await z("audit",e)}async function Q(){let e=await _();return new Promise((t,r)=>{let i=e.transaction("audit","readonly").objectStore("audit").index("by-seqNum").getAll();i.onsuccess=()=>{t(i.result)},i.onerror=()=>{r(new Error("Failed to get audit entries"))}})}async function We(){let e=await Q();return e.length>0?e[e.length-1]:null}async function be(e){await z("leases",e)}async function ee(e){return await ce("leases",e)??null}async function Ke(e){let t=await _();return new Promise((r,n)=>{let o=t.transaction("leases","readonly").objectStore("leases").index("by-userId").getAll(e);o.onsuccess=()=>{r(o.result)},o.onerror=()=>{n(new Error("Failed to get user leases"))}})}async function te(e){await ke("leases",e)}async function Fe(e){let r=(await V()).filter(a=>a.purpose==="vapid");if(r.length===0)throw new Error("No VAPID key found. Generate a VAPID key first.");if(r.length>1)throw new Error("Multiple VAPID keys found. Cannot determine which to update.");let n=r[0];if(!n)throw new Error("No VAPID key found after filtering");let s={...n,subscription:e};await z("keys",s)}async function $e(){let t=(await V()).filter(a=>a.purpose==="vapid");if(t.length===0)throw new Error("No VAPID key found");if(t.length>1)throw new Error("Multiple VAPID keys found. Cannot determine which to update.");let r=t[0];if(!r)throw new Error("No VAPID key found after filtering");let{subscription:n,...s}=r;await z("keys",s)}async function Ae(){let t=(await V()).filter(n=>n.purpose==="vapid");if(t.length===0)throw new Error("No VAPID key found");if(t.length>1)throw new Error("Multiple VAPID keys found. Cannot determine which to read.");let r=t[0];if(!r)throw new Error("No VAPID key found after filtering");return r.subscription??null}var le=e=>`enrollment:passphrase:v2:${e}`,pe=e=>`enrollment:passkey-prf:v2:${e}`,ye=e=>`enrollment:passkey-gate:v2:${e}`;function Ie(){let e=new Uint8Array(32);return crypto.getRandomValues(e),e}async function fe(e,t,r){let n=r??Ie(),{iterations:s}=await Me(),a=crypto.getRandomValues(new Uint8Array(16)),i=await crypto.subtle.importKey("raw",new TextEncoder().encode(t),"PBKDF2",!1,["deriveKey"]),o=await crypto.subtle.deriveKey({name:"PBKDF2",hash:"SHA-256",salt:a,iterations:s},i,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),u=await he(o),d=crypto.getRandomValues(new Uint8Array(12)),c=oe({kmsVersion:2,method:"passphrase",algVersion:1,purpose:"master-secret"}),l=await crypto.subtle.encrypt({name:"AES-GCM",iv:d,additionalData:c},o,n),p={kmsVersion:2,algVersion:1,method:"passphrase",kdf:{algorithm:"PBKDF2-HMAC-SHA256",iterations:s,salt:a.buffer.slice(a.byteOffset,a.byteOffset+a.byteLength),lastCalibratedAt:Date.now(),platformHash:""},kcv:u,encryptedMS:l,msIV:d.buffer.slice(d.byteOffset,d.byteOffset+d.byteLength),msAAD:c,msVersion:1,createdAt:Date.now(),updatedAt:Date.now()};return await U(le(e),p),{success:!0,ms:n}}async function we(e,t,r,n,s="",a,i){let o=n??Ie(),u=a??crypto.getRandomValues(new Uint8Array(32)),d=i??await Z("ATS/KMS/KEK-wrap/salt/v2"),c=new TextEncoder().encode("ATS/KMS/KEK-wrap/v2"),l=await crypto.subtle.importKey("raw",r,"HKDF",!1,["deriveKey"]),p=d instanceof Uint8Array?d.buffer:d,f=await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:p,info:c},l,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]),y=crypto.getRandomValues(new Uint8Array(12)),w=oe({kmsVersion:2,method:"passkey-prf",algVersion:1,credentialId:t,purpose:"master-secret"}),K=await crypto.subtle.encrypt({name:"AES-GCM",iv:y,additionalData:w},f,o),b=Date.now(),h=u.buffer.slice(u.byteOffset,u.byteOffset+u.byteLength),v;d instanceof Uint8Array?v=d.buffer.slice(d.byteOffset,d.byteOffset+d.byteLength):v=d;let E={kmsVersion:2,algVersion:1,method:"passkey-prf",credentialId:t,rpId:s,kdf:{algorithm:"HKDF-SHA256",appSalt:h,hkdfSalt:v,info:"ATS/KMS/KEK-wrap/v2"},encryptedMS:K,msIV:y.buffer.slice(y.byteOffset,y.byteOffset+y.byteLength),msAAD:w,msVersion:1,createdAt:b,updatedAt:b};return await U(pe(e),E),{success:!0,ms:o}}async function ge(e,t,r,n=""){let s=r??Ie(),a=crypto.getRandomValues(new Uint8Array(32)),i=await Z("ATS/KMS/KEK-gate/salt/v2"),o=new TextEncoder().encode("ATS/KMS/KEK-gate/v2"),u=await crypto.subtle.importKey("raw",a,"HKDF",!1,["deriveKey"]),d=await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:i,info:o},u,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]),c=crypto.getRandomValues(new Uint8Array(12)),l=oe({kmsVersion:2,method:"passkey-gate",algVersion:1,credentialId:t,purpose:"master-secret"}),p=await crypto.subtle.encrypt({name:"AES-GCM",iv:c,additionalData:l},d,s),f=Date.now(),y={kmsVersion:2,algVersion:1,method:"passkey-gate",credentialId:t,rpId:n,pepperWrapped:a.buffer.slice(a.byteOffset,a.byteOffset+a.byteLength),encryptedMS:p,msIV:c.buffer.slice(c.byteOffset,c.byteOffset+c.byteLength),msAAD:l,msVersion:1,createdAt:f,updatedAt:f};return await U(ye(e),y),{success:!0,ms:s}}async function Mt(e,t){let r=await C(le(e));if(!r)return{success:!1,error:"Passphrase not set up"};let n=await crypto.subtle.importKey("raw",new TextEncoder().encode(t),"PBKDF2",!1,["deriveKey"]),s=await crypto.subtle.deriveKey({name:"PBKDF2",hash:"SHA-256",salt:r.kdf.salt,iterations:r.kdf.iterations},n,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),a=await he(s);if(!Le(a,r.kcv))return{success:!1,error:"Invalid passphrase"};try{let i=await crypto.subtle.decrypt({name:"AES-GCM",iv:r.msIV,additionalData:r.msAAD},s,r.encryptedMS);return{success:!0,ms:new Uint8Array(i)}}catch{return{success:!1,error:"Decryption failed"}}}async function Bt(e,t){let r=await C(pe(e));if(!r)return{success:!1,error:"Passkey not set up"};let n=r.kdf.hkdfSalt,s=new TextEncoder().encode(r.kdf.info),a=await crypto.subtle.importKey("raw",t,"HKDF",!1,["deriveKey"]),i=await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:n,info:s},a,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]);try{let o=await crypto.subtle.decrypt({name:"AES-GCM",iv:r.msIV,additionalData:r.msAAD},i,r.encryptedMS);return{success:!0,ms:new Uint8Array(o)}}catch{return{success:!1,error:"Decryption failed"}}}async function Ht(e){let t=await C(ye(e));if(!t)return{success:!1,error:"Passkey gate not set up"};let r=new Uint8Array(t.pepperWrapped),n=await Z("ATS/KMS/KEK-gate/salt/v2"),s=new TextEncoder().encode("ATS/KMS/KEK-gate/v2"),a=await crypto.subtle.importKey("raw",r,"HKDF",!1,["deriveKey"]),i=await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:n,info:s},a,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"]);try{let o=await crypto.subtle.decrypt({name:"AES-GCM",iv:t.msIV,additionalData:t.msAAD},i,t.encryptedMS);return{success:!0,ms:new Uint8Array(o)}}catch{return{success:!1,error:"Decryption failed"}}}async function ve(e){let t=await C(le(e)),r=await C(pe(e)),n=await C(ye(e));return!!(t||r||n)}async function Pe(e){return!!await C(le(e))}async function Se(e){let t=await C(pe(e)),r=await C(ye(e));return!!(t||r)}async function re(e){let t=await Z("ATS/KMS/MKEK/salt/v2"),r=new TextEncoder().encode("ATS/KMS/MKEK/v2"),n=await crypto.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:t,info:r},n,{name:"AES-GCM",length:256},!1,["encrypt","decrypt","wrapKey","unwrapKey"])}async function B(e,t){let r=Date.now(),n=null;try{let s;switch(e.method){case"passphrase":s=await Mt(e.userId,e.passphrase);break;case"passkey-prf":s=await Bt(e.userId,e.prfOutput);break;case"passkey-gate":s=await Ht(e.userId);break;default:throw new Error("Unknown credential method")}if(!s.success)throw new Error(s.error??"Unlock failed");n=s.ms;let a=await re(n),i=await t(a,n),o=Date.now();return{result:i,unlockTime:r,lockTime:o,duration:o-r}}finally{n&&n.fill(0)}}var Ee=Promise.resolve(),D=null;async function Ge(){}async function me(){let e=await C("LRK");return e||(e=await crypto.subtle.generateKey({name:"AES-GCM",length:256},!1,["wrapKey","unwrapKey","encrypt","decrypt"]),await U("LRK",e)),e}async function ne(e){let t=await crypto.subtle.digest("SHA-256",e);return g(t)}async function L(e){let t=await H("audit-user");if(t&&t.publicKeyRaw){let a=await crypto.subtle.unwrapKey("pkcs8",t.wrappedKey,e,{name:"AES-GCM",iv:t.iv,additionalData:t.aad},{name:"Ed25519"},!1,["sign"]),i=await crypto.subtle.importKey("raw",t.publicKeyRaw,{name:"Ed25519"},!1,["verify"]),o=await ne(t.publicKeyRaw);D={type:"UAK",keyPair:{privateKey:a,publicKey:i},keyId:o};return}let r=await crypto.subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),n=await crypto.subtle.exportKey("raw",r.publicKey);await M(r.privateKey,e,"audit-user",{name:"Ed25519"},["sign"],{alg:"EdDSA",purpose:"audit",publicKeyRaw:n});let s=await ne(n);D={type:"UAK",keyPair:r,keyId:s}}async function Ne(e,t){if(!D||D.type!=="UAK")throw new Error("UAK must be active to generate LAK - call ensureAuditKey first");let r=Date.now(),n=await crypto.subtle.generateKey({name:"Ed25519"},!0,["sign","verify"]),s=await crypto.subtle.exportKey("raw",n.publicKey),a=g(s),i={type:"audit-delegation",version:1,signerKind:"LAK",leaseId:e,delegatePub:a,scope:["vapid:issue","lease:expire"],notBefore:r,notAfter:t,codeHash:"TODO",manifestHash:"TODO",kmsVersion:"v2.0.0"},o=JSON.stringify(i,Object.keys(i).sort()),u=await crypto.subtle.sign("Ed25519",D.keyPair.privateKey,new TextEncoder().encode(o)),d={...i,sig:g(u)},c=await me(),l=ue({kmsVersion:2,kid:`lak-${e}`,alg:"EdDSA",purpose:"lak",createdAt:r,keyType:"lease-audit-key"}),p=crypto.getRandomValues(new Uint8Array(12)),f=await crypto.subtle.wrapKey("pkcs8",n.privateKey,c,{name:"AES-GCM",iv:p,additionalData:l});return await U(`lease-audit-key:${e}`,{leaseId:e,wrappedKey:f,iv:p,aad:l,publicKeyRaw:s,delegationCert:d,expiresAt:t,createdAt:r}),{lakKeyPair:n,delegationCert:d}}async function Je(e,t){let r=await C(`lease-audit-key:${e}`);if(!r)throw new Error(`LAK not found for lease: ${e}`);let n=await me(),s=await crypto.subtle.unwrapKey("pkcs8",r.wrappedKey,n,{name:"AES-GCM",iv:r.iv,additionalData:r.aad},{name:"Ed25519"},!1,["sign"]),a=await crypto.subtle.importKey("raw",r.publicKeyRaw,{name:"Ed25519"},!1,["verify"]),i=await ne(r.publicKeyRaw);D={type:"LAK",keyPair:{privateKey:s,publicKey:a},keyId:i,cert:t}}async function _e(){let e=await H("audit-instance");if(e&&e.publicKeyRaw){let u=await me(),d=await crypto.subtle.unwrapKey("pkcs8",e.wrappedKey,u,{name:"AES-GCM",iv:e.iv,additionalData:e.aad},{name:"Ed25519"},!1,["sign"]),c=await crypto.subtle.importKey("raw",e.publicKeyRaw,{name:"Ed25519"},!1,["verify"]),l=await ne(e.publicKeyRaw);D={type:"KIAK",keyPair:{privateKey:d,publicKey:c},keyId:l};return}let t=await me(),r=await crypto.subtle.generateKey({name:"Ed25519"},!0,["sign"]),n=await crypto.subtle.exportKey("raw",r.publicKey);await M(r.privateKey,t,"audit-instance",{name:"Ed25519"},["sign"],{alg:"EdDSA",purpose:"audit-instance",publicKeyRaw:n});let s=await H("audit-instance");if(!s)throw new Error("Failed to retrieve wrapped KIAK after storage");let a=await crypto.subtle.unwrapKey("pkcs8",s.wrappedKey,t,{name:"AES-GCM",iv:s.iv,additionalData:s.aad},{name:"Ed25519"},!1,["sign"]),i=await crypto.subtle.importKey("raw",n,{name:"Ed25519"},!1,["verify"]),o=await ne(n);D={type:"KIAK",keyPair:{privateKey:a,publicKey:i},keyId:o}}async function R(e){let t,r,n=new Promise((s,a)=>{t=s,r=a});return Ee=Ee.then(async()=>{try{if(!D)throw new Error("No active audit signer - call ensureAuditKey, loadLAK, or ensureKIAK first");let s=Date.now(),a=await We(),i=a?a.chainHash:"",u={kmsVersion:2,seqNum:a?a.seqNum+1:1,timestamp:s,op:e.op,kid:e.kid,requestId:e.requestId,userId:e.userId,origin:e.origin,leaseId:e.leaseId,unlockTime:e.unlockTime,lockTime:e.lockTime,duration:e.duration,details:e.details,previousHash:i,signer:D.type,signerId:D.keyId},d=JSON.stringify(u),c=new TextEncoder().encode(i+d),l=await crypto.subtle.digest("SHA-256",c),p=g(l),f=new TextEncoder().encode(p),y=await crypto.subtle.sign("Ed25519",D.keyPair.privateKey,f),w=g(y),K={kmsVersion:u.kmsVersion,seqNum:u.seqNum,timestamp:u.timestamp,op:u.op,kid:u.kid,requestId:u.requestId,userId:u.userId,...u.origin!==void 0&&{origin:u.origin},...u.leaseId!==void 0&&{leaseId:u.leaseId},...u.unlockTime!==void 0&&{unlockTime:u.unlockTime},...u.lockTime!==void 0&&{lockTime:u.lockTime},...u.duration!==void 0&&{duration:u.duration},...u.details!==void 0&&{details:u.details},previousHash:u.previousHash,chainHash:p,signer:u.signer,signerId:u.signerId,...D.cert!==void 0&&{cert:D.cert},sig:w};await qe(K),t(K)}catch(s){r(s)}}).catch(()=>{}),n}async function ze(){let e=await Q(),t=[],r=0;for(let n of e){let s={kmsVersion:n.kmsVersion,seqNum:n.seqNum,timestamp:n.timestamp,op:n.op,kid:n.kid,requestId:n.requestId,userId:n.userId,origin:n.origin,leaseId:n.leaseId,unlockTime:n.unlockTime,lockTime:n.lockTime,duration:n.duration,details:n.details,previousHash:n.previousHash,signer:n.signer,signerId:n.signerId},a=JSON.stringify(s),i=new TextEncoder().encode(n.previousHash+a),o=await crypto.subtle.digest("SHA-256",i);g(o)!==n.chainHash&&t.push(`Chain hash mismatch at seq ${n.seqNum}`),r+=1}return{valid:t.length===0,verified:r,errors:t}}async function Qe(){let e=await H("audit-user");if(!e||!e.publicKeyRaw)throw new Error("UAK not initialized");return{publicKey:g(e.publicKeyRaw)}}function Xe(){D=null,Ee=Promise.resolve()}function se(e){if(e instanceof Error)return e.message;if(typeof e=="string")return e;if(typeof e=="object"&&e!==null&&"message"in e&&typeof e.message=="string")return e.message;try{return String(e)}catch{return"Unknown error"}}var P=class extends Error{constructor(r,n,s,a){super(`RPC ${r}: Invalid ${n} - expected ${s}, got ${typeof a}`);this.method=r;this.param=n;this.expected=s;this.received=a;this.name="RPCValidationError"}};function S(e,t){if(typeof t!="object"||t===null)throw new P(e,"params","object",t);return t}function I(e,t,r){if(typeof r!="string")throw new P(e,t,"string",r);return r}function W(e,t,r){if(r!==void 0)return I(e,t,r)}function ae(e,t,r){if(typeof r!="number")throw new P(e,t,"number",r);return r}function Ot(e,t,r){if(typeof r!="boolean")throw new P(e,t,"boolean",r);return r}function Ye(e,t,r){if(r!==void 0)return Ot(e,t,r)}function xe(e,t,r){if(r instanceof ArrayBuffer)return r;if(r instanceof Uint8Array){let n=new ArrayBuffer(r.byteLength);return new Uint8Array(n).set(r),n}throw new P(e,t,"ArrayBuffer or Uint8Array",r)}function Ce(e,t,r){if(r!==void 0){if(r instanceof Uint8Array)return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);throw new P(e,t,"ArrayBuffer or Uint8Array",r)}}function F(e,t){if(typeof t!="object"||t===null)throw new P(e,"credentials","AuthCredentials object",t);let r=t;if(typeof r.method!="string")throw new P(e,"credentials.method","string",r.method);if(typeof r.userId!="string")throw new P(e,"credentials.userId","string",r.userId);switch(r.method){case"passphrase":if(typeof r.passphrase!="string")throw new P(e,"credentials.passphrase","string",r.passphrase);return{method:"passphrase",passphrase:r.passphrase,userId:r.userId};case"passkey-prf":if(!(r.prfOutput instanceof ArrayBuffer))throw new P(e,"credentials.prfOutput","ArrayBuffer",r.prfOutput);return{method:"passkey-prf",prfOutput:r.prfOutput,userId:r.userId};case"passkey-gate":return{method:"passkey-gate",userId:r.userId};default:throw new P(e,"credentials.method","passphrase | passkey-prf | passkey-gate",r.method)}}function jt(e,t){if(typeof t!="object"||t===null)throw new P(e,"payload","VAPIDPayload object",t);let r=t;return{aud:I(e,"payload.aud",r.aud),sub:I(e,"payload.sub",r.sub),exp:ae(e,"payload.exp",r.exp),jti:I(e,"payload.jti",r.jti)}}function Ze(e){let t=S("setupPassphrase",e),r=Ce("setupPassphrase","existingMS",t.existingMS);return{userId:I("setupPassphrase","userId",t.userId),passphrase:I("setupPassphrase","passphrase",t.passphrase),...r!==void 0&&{existingMS:r}}}function et(e){let t=S("setupPasskeyPRF",e);if(!t.credentialId)throw new Error("credentialId required");let r=W("setupPasskeyPRF","rpId",t.rpId),n=Ce("setupPasskeyPRF","existingMS",t.existingMS);return{userId:I("setupPasskeyPRF","userId",t.userId),credentialId:xe("setupPasskeyPRF","credentialId",t.credentialId),prfOutput:xe("setupPasskeyPRF","prfOutput",t.prfOutput),...r!==void 0&&{rpId:r},...n!==void 0&&{existingMS:n}}}function tt(e){let t=S("setupWithPopup",e);return{userId:I("setupWithPopup","userId",t.userId)}}function rt(e){let t=S("fullSetup",e),n={userId:I("fullSetup","userId",t.userId)};if(t.autoExtend!==void 0){if(typeof t.autoExtend!="boolean")throw new P("fullSetup","autoExtend","boolean",typeof t.autoExtend);n.autoExtend=t.autoExtend}if(t.ttlHours!==void 0){let s=ae("fullSetup","ttlHours",t.ttlHours);if(s<=0||s>720)throw new P("fullSetup","ttlHours","0 < ttlHours <= 720",s);n.ttlHours=s}return n}function nt(e){let t=S("setupPasskeyGate",e),r=W("setupPasskeyGate","rpId",t.rpId),n=Ce("setupPasskeyGate","existingMS",t.existingMS);return{userId:I("setupPasskeyGate","userId",t.userId),credentialId:xe("setupPasskeyGate","credentialId",t.credentialId),...r!==void 0&&{rpId:r},...n!==void 0&&{existingMS:n}}}function st(e){let t=S("addEnrollment",e);return{userId:I("addEnrollment","userId",t.userId),credentials:F("addEnrollment",t.credentials)}}function at(e){let t=S("addEnrollmentWithPopup",e);return{userId:I("addEnrollmentWithPopup","userId",t.userId)}}function it(e){let t=S("generateVAPID",e);return{credentials:F("generateVAPID",t.credentials)}}function ot(e){let t=S("regenerateVAPID",e);return{credentials:F("regenerateVAPID",t.credentials)}}function ut(e){let t=S("signJWT",e);return{kid:I("signJWT","kid",t.kid),payload:jt("signJWT",t.payload),credentials:F("signJWT",t.credentials)}}function dt(e){let t=S("createLease",e),r={userId:I("createLease","userId",t.userId),ttlHours:ae("createLease","ttlHours",t.ttlHours),credentials:F("createLease",t.credentials)},n=Ye("createLease","autoExtend",t.autoExtend);return n!==void 0&&(r.autoExtend=n),r}function ct(e){let t=S("extendLeases",e);if(!Array.isArray(t.leaseIds))throw new Error(`RPC extendLeases: Invalid leaseIds - expected array, got ${typeof t.leaseIds}`);if(t.leaseIds.length===0)throw new Error("RPC extendLeases: leaseIds array cannot be empty");let n={leaseIds:t.leaseIds.map((a,i)=>{if(typeof a!="string"||a.length===0)throw new Error(`RPC extendLeases: Invalid leaseId at index ${i} - expected non-empty string`);return a}),userId:I("extendLeases","userId",t.userId)},s=Ye("extendLeases","requestAuth",t.requestAuth);return s!==void 0&&(n.requestAuth=s),t.credentials!==void 0&&(n.credentials=F("extendLeases",t.credentials)),n}function lt(e){let t=S("issueVAPIDJWT",e),r=W("issueVAPIDJWT","kid",t.kid),n=W("issueVAPIDJWT","jti",t.jti),s=t.exp!==void 0?ae("issueVAPIDJWT","exp",t.exp):void 0;return{leaseId:I("issueVAPIDJWT","leaseId",t.leaseId),...r!==void 0&&{kid:r},...n!==void 0&&{jti:n},...s!==void 0&&{exp:s}}}function pt(e){let t=S("issueVAPIDJWTs",e),r=W("issueVAPIDJWTs","kid",t.kid);return{leaseId:I("issueVAPIDJWTs","leaseId",t.leaseId),count:ae("issueVAPIDJWTs","count",t.count),...r!==void 0&&{kid:r}}}function yt(e){if(e==null)return{};let t=S("isSetup",e),r=W("isSetup","userId",t.userId);return r!==void 0?{userId:r}:{}}function ft(e){if(e==null)return{};let t=S("getEnrollments",e),r=W("getEnrollments","userId",t.userId);return r!==void 0?{userId:r}:{}}function wt(e){let t=S("getPublicKey",e);return{kid:I("getPublicKey","kid",t.kid)}}function gt(e){let t=S("getUserLeases",e);return{userId:I("getUserLeases","userId",t.userId)}}function mt(e){let t=S("verifyLease",e),r={leaseId:I("verifyLease","leaseId",t.leaseId)};if("deleteIfInvalid"in t){if(typeof t.deleteIfInvalid!="boolean")throw new Error("verifyLease: deleteIfInvalid must be a boolean");r.deleteIfInvalid=t.deleteIfInvalid}return r}function ht(e){let t=S("removeEnrollment",e);return{enrollmentId:I("removeEnrollment","enrollmentId",t.enrollmentId),credentials:F("removeEnrollment",t.credentials)}}var qt=["fcm.googleapis.com","web.push.apple.com","updates.push.services.mozilla.com","notify.windows.com"];function Wt(e,t){if(typeof t!="object"||t===null)throw new P(e,"subscription","object",t);let r=t,n=I(e,"subscription.endpoint",r.endpoint);if(!n.startsWith("https://"))throw new Error(`${e}: subscription.endpoint must use HTTPS`);let s;try{s=new URL(n)}catch{throw new Error(`${e}: subscription.endpoint is not a valid URL`)}if(!qt.some(p=>s.hostname===p||s.hostname.endsWith(`.${p}`)))throw new Error(`${e}: subscription.endpoint must be from a known push service (FCM, APNs, Mozilla Push, WNS). Got: ${s.hostname}`);let i=r.expirationTime;if(i!==null&&typeof i!="number")throw new P(e,"subscription.expirationTime","number or null",i);if(typeof r.keys!="object"||r.keys===null)throw new P(e,"subscription.keys","object",r.keys);let o=r.keys,u=I(e,"subscription.keys.p256dh",o.p256dh),d=I(e,"subscription.keys.auth",o.auth);if(u.length===0)throw new Error(`${e}: subscription.keys.p256dh must be non-empty`);if(d.length===0)throw new Error(`${e}: subscription.keys.auth must be non-empty`);let c=I(e,"subscription.eid",r.eid);if(c.length===0)throw new Error(`${e}: subscription.eid must be non-empty`);let l=r.createdAt;if(typeof l!="number")throw new P(e,"subscription.createdAt","number",l);return{endpoint:n,expirationTime:i,keys:{p256dh:u,auth:d},eid:c,createdAt:l}}function kt(e){let t=S("setPushSubscription",e);return{subscription:Wt("setPushSubscription",t.subscription)}}function $t(e){if(typeof e!="object"||e===null)return!1;let t=e;return typeof t.tokensIssued=="number"&&typeof t.lastResetAt=="number"}function bt(e){return $t(e)?e:{tokensIssued:0,lastResetAt:Date.now()}}var De=new Map,O=new Map,$=new Map,ie=new Map,X=new Map;async function Gt(e,t){let r=await crypto.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return await crypto.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:t,info:new TextEncoder().encode("ATS/KMS/SessionKEK/v1")},r,{name:"AES-GCM",length:256},!1,["wrapKey","unwrapKey"])}async function Re(){let e=await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveBits"]),t=await crypto.subtle.exportKey("raw",e.publicKey),r=crypto.randomUUID(),n=crypto.getRandomValues(new Uint8Array(32)),s=crypto.getRandomValues(new Uint8Array(32));return O.set(r,{privateKey:e.privateKey,appSalt:n,hkdfSalt:s,createdAt:Date.now()}),setTimeout(()=>{O.delete(r)},10*60*1e3),{publicKey:g(t),keyId:r,appSalt:g(n.buffer),hkdfSalt:g(s.buffer)}}async function Nt(e){let t=O.get(e.transportKeyId);if(!t)throw new Error("Transport key not found or expired");let r=x(e.ephemeralPublicKey),n=await crypto.subtle.importKey("raw",r,{name:"ECDH",namedCurve:"P-256"},!1,[]),s=await crypto.subtle.deriveBits({name:"ECDH",public:n},t.privateKey,256),a=await crypto.subtle.importKey("raw",s,"HKDF",!1,["deriveBits"]),i=await crypto.subtle.deriveBits({name:"HKDF",salt:new Uint8Array(32),info:new TextEncoder().encode("ATS/KMS/setup-transport/v2"),hash:"SHA-256"},a,256),o=await crypto.subtle.importKey("raw",i,{name:"AES-GCM",length:256},!1,["decrypt"]),u=x(e.iv),d=x(e.encryptedCredentials),c=await crypto.subtle.decrypt({name:"AES-GCM",iv:u,tagLength:128},o,d),l=JSON.parse(new TextDecoder().decode(c)),p,f;if(e.method==="passphrase"){let y=l;p=await At({userId:e.userId,passphrase:y.passphrase},e.requestId),f={method:"passphrase",passphrase:y.passphrase,userId:e.userId}}else if(e.method==="passkey-prf"){let y=l,w=x(y.prfOutput);p=await It({userId:e.userId,credentialId:x(y.credentialId),prfOutput:w,...y.rpId!==void 0&&{rpId:y.rpId},appSalt:t.appSalt,hkdfSalt:t.hkdfSalt},e.requestId),f={method:"passkey-prf",prfOutput:w,userId:e.userId}}else if(e.method==="passkey-gate"){let y=l;p=await vt({userId:e.userId,credentialId:x(y.credentialId),...y.rpId!==void 0&&{rpId:y.rpId}},e.requestId),f={method:"passkey-gate",userId:e.userId}}else{let y=e.method;throw new Error(`Unknown method: ${String(y)}`)}return O.delete(e.transportKeyId),{...p,credentials:f}}async function Kt(e,t){let r=await Re(),n=new URL("https://kms.ats.run/");n.searchParams.set("mode","setup");let a=await new Promise((o,u)=>{let d=setTimeout(()=>{u(new Error("Setup with popup timeout"))},3e5);$.set(t,{resolve:o,reject:u,timeout:d}),self.postMessage({type:"worker:setup-with-popup",requestId:t,userId:e.userId,popupURL:n.toString(),transportKey:r.publicKey,transportKeyId:r.keyId,appSalt:r.appSalt,hkdfSalt:r.hkdfSalt})});return await Nt({method:a.method,transportKeyId:a.transportKeyId,ephemeralPublicKey:a.ephemeralPublicKey,iv:a.iv,encryptedCredentials:a.encryptedCredentials,userId:a.userId,requestId:t})}async function Jt(e,t){let{userId:r,autoExtend:n=!0,ttlHours:s=12}=e;if(s<=0||s>720)throw new Error("ttlHours must be between 0 and 720 (30 days)");if(await ve(r))throw new Error("User already has authentication setup. Use addEnrollment to add additional methods.");let i=await Kt({userId:r},`${t}-setup`),o=i.credentials,u=i.vapidPublicKey,d=i.vapidKid,c=i.enrollmentId,l=await new Promise((w,K)=>{let b=setTimeout(()=>{K(new Error("Push subscription timeout (60s)"))},6e4),h=`${t}-push-sub`;X.set(h,{resolve:w,reject:K,timeout:b}),self.postMessage({type:"worker:request-push-subscription",requestId:h,vapidPublicKey:u,userId:r})});await xt({subscription:l});let p=await Pt({userId:r,ttlHours:s,credentials:o,autoExtend:n},`${t}-lease`),y=(await Et({leaseId:p.leaseId,count:5,kid:d},`${t}-jwts`)).map(w=>({jwt:w.jwt,jti:w.jti,exp:w.exp}));try{let w=y[0];await new Promise((K,b)=>{let h=setTimeout(()=>{b(new Error("Test notification timeout (30s)"))},3e4),v=`${t}-test-notif`;X.set(v,{resolve:K,reject:b,timeout:h}),self.postMessage({type:"worker:send-test-notification",requestId:v,jwt:w.jwt,subscription:l,vapidPublicKey:u})})}catch(w){console.warn("[KMS Worker] Test notification failed (non-fatal):",se(w))}return o.method==="passphrase"?o.passphrase="":o.method==="passkey-prf"&&new Uint8Array(o.prfOutput).fill(0),await R({op:"full-setup",kid:d,requestId:t,userId:r,details:{action:"full-setup",enrollmentId:c,leaseId:p.leaseId,autoExtend:n,ttlHours:s,jwtCount:y.length}}),{success:!0,enrollmentId:c,vapidPublicKey:u,vapidKid:d,leaseId:p.leaseId,leaseExp:p.exp,autoExtend:p.autoExtend??!0,jwts:y,subscription:l}}self.addEventListener("message",e=>{let t=e.data;if("type"in t&&t.type==="worker:popup-credentials"){let r=t.requestId;if(r&&t.credentials){let n=$.get(r);n&&(clearTimeout(n.timeout),$.delete(r),n.resolve(t.credentials))}return}if("type"in t&&t.type==="worker:popup-error"){let r=t.requestId;if(r){let n=$.get(r);n&&(clearTimeout(n.timeout),$.delete(r),n.reject(new Error(t.reason||"Popup setup failed")))}return}if("type"in t&&t.type==="worker:unlock-credentials"){let r=t.requestId,n=t.credentials;if(r&&n){let s=ie.get(r);s&&(clearTimeout(s.timeout),ie.delete(r),s.resolve(n))}return}if("type"in t&&t.type==="worker:unlock-error"){let r=t.requestId;if(r){let n=ie.get(r);n&&(clearTimeout(n.timeout),ie.delete(r),n.reject(new Error(t.reason||"Unlock failed")))}return}if("type"in t&&t.type==="worker:push-subscription-result"){let r=t,n=r.requestId,s=r.subscription,a=r.error;if(n){let i=X.get(n);i&&(clearTimeout(i.timeout),X.delete(n),s?i.resolve(s):i.reject(new Error(a||"Push subscription failed")))}return}if("type"in t&&t.type==="worker:test-notification-result"){let r=t,n=r.requestId,s=r.success,a=r.error;if(n){let i=X.get(n);i&&(clearTimeout(i.timeout),X.delete(n),s?i.resolve(void 0):i.reject(new Error(a||"Test notification failed")))}return}(async()=>{let r=e.data,n=await _t(r);self.postMessage(n)})().catch(r=>{console.error("[KMS Worker] Message handling failed:",r);let n=e.data;self.postMessage({id:n?.id||"unknown",error:r instanceof Error?r.message:"Unknown error"})})});async function _t(e){let{id:t,method:r,params:n}=e;try{let s;switch(r){case"setupWithPopup":{let a=await Kt(tt(n),t);s={success:a.success,enrollmentId:a.enrollmentId,vapidPublicKey:a.vapidPublicKey,vapidKid:a.vapidKid};break}case"fullSetup":s=await Jt(rt(n),t);break;case"setupPassphrase":s=await At(Ze(n),t);break;case"setupPasskeyPRF":s=await It(et(n),t);break;case"setupPasskeyGate":s=await vt(nt(n),t);break;case"addEnrollment":s=await zt(st(n),t);break;case"addEnrollmentWithPopup":s=await Qt(at(n),t);break;case"generateVAPID":s=await Xt(it(n),t);break;case"regenerateVAPID":s=await Yt(ot(n),t);break;case"signJWT":s=await Zt(ut(n),t);break;case"createLease":s=await Pt(dt(n),t);break;case"extendLeases":s=await er(ct(n),t);break;case"issueVAPIDJWT":s=await St(lt(n),t);break;case"issueVAPIDJWTs":s=await Et(pt(n),t);break;case"isSetup":s=await tr(yt(n));break;case"getEnrollments":s=await rr(ft(n));break;case"verifyAuditChain":s=await nr();break;case"getAuditLog":s=await sr();break;case"getPublicKey":s=await ar(wt(n));break;case"getAuditPublicKey":s=await ir();break;case"getUserLeases":s=await or(gt(n));break;case"verifyLease":s=await ur(mt(n));break;case"getVAPIDKid":s=await dr();break;case"resetKMS":s=await pr();break;case"removeEnrollment":s=await yr(ht(n),t);break;case"setPushSubscription":s=await xt(kt(n));break;case"removePushSubscription":s=await cr();break;case"getPushSubscription":s=await lr();break;default:throw new Error(`Unknown RPC method: ${r}`)}return{id:t,result:s}}catch(s){return{id:t,error:se(s)}}}async function At(e,t){let{userId:r,passphrase:n,existingMS:s}=e;if(!n||n.length<8)throw new Error("Passphrase must be at least 8 characters");let a=await fe(r,n,s);if(!a.success)throw new Error(a.error);let i=await re(a.ms);await L(i);let o=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"]);if(!("privateKey"in o)||!("publicKey"in o))throw new Error("Failed to generate ECDSA keypair");let u=o,d=await crypto.subtle.exportKey("raw",u.publicKey),c=N(new Uint8Array(d)),l=await J(c);return await M(u.privateKey,i,l,{name:"ECDSA",namedCurve:"P-256"},["sign"],{alg:"ES256",purpose:"vapid",publicKeyRaw:d}),a.ms.fill(0),await R({op:"setup-passphrase",kid:"",requestId:t,userId:r,details:{method:"passphrase",vapidKid:l}}),{success:!0,enrollmentId:"enrollment:passphrase:v2",vapidPublicKey:g(d),vapidKid:l}}async function It(e,t){let{userId:r,credentialId:n,prfOutput:s,rpId:a="",existingMS:i,appSalt:o,hkdfSalt:u}=e;if(!n||n.byteLength===0)throw new Error("credentialId required");if(!s||s.byteLength!==32)throw new Error("prfOutput must be 32 bytes");let d=await we(r,n,s,i,a,o,u);if(!d.success)throw new Error(d.error);let c=await re(d.ms);await L(c);let l=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"]);if(!("privateKey"in l)||!("publicKey"in l))throw new Error("Failed to generate ECDSA keypair");let p=l,f=await crypto.subtle.exportKey("raw",p.publicKey),y=N(new Uint8Array(f)),w=await J(y);return await M(p.privateKey,c,w,{name:"ECDSA",namedCurve:"P-256"},["sign"],{alg:"ES256",purpose:"vapid",publicKeyRaw:f}),d.ms.fill(0),await R({op:"setup-passkey-prf",kid:"",requestId:t,userId:r,details:{method:"passkey-prf",credentialId:g(n),vapidKid:w}}),{success:!0,enrollmentId:"enrollment:passkey-prf:v2",vapidPublicKey:g(f),vapidKid:w}}async function vt(e,t){let{userId:r,credentialId:n,rpId:s="",existingMS:a}=e;if(!n||n.byteLength===0)throw new Error("credentialId required");let i=await ge(r,n,a,s);if(!i.success)throw new Error(i.error);let o=await re(i.ms);await L(o);let u=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"]);if(!("privateKey"in u)||!("publicKey"in u))throw new Error("Failed to generate ECDSA keypair");let d=u,c=await crypto.subtle.exportKey("raw",d.publicKey),l=N(new Uint8Array(c)),p=await J(l);return await M(d.privateKey,o,p,{name:"ECDSA",namedCurve:"P-256"},["sign"],{alg:"ES256",purpose:"vapid",publicKeyRaw:c}),i.ms.fill(0),await R({op:"setup-passkey-gate",kid:"",requestId:t,userId:r,details:{method:"passkey-gate",credentialId:g(n),vapidKid:p}}),{success:!0,enrollmentId:"enrollment:passkey-gate:v2",vapidPublicKey:g(c),vapidKid:p}}async function zt(e,t){let{userId:r,credentials:n}=e,a=(await B(n,async(k,T)=>(await L(k),T))).result,i=await Re(),o=new URL("https://kms.ats.run/");o.searchParams.set("mode","setup");let d=await new Promise((k,T)=>{let G=setTimeout(()=>{console.error("[Worker] Popup timeout after 5 minutes"),T(new Error("Add enrollment popup timeout"))},3e5);$.set(t,{resolve:k,reject:T,timeout:G}),self.postMessage({type:"worker:setup-with-popup",requestId:t,userId:e.userId,popupURL:o.toString(),transportKey:i.publicKey,transportKeyId:i.keyId,appSalt:i.appSalt,hkdfSalt:i.hkdfSalt})}),c=O.get(d.transportKeyId);if(!c)throw new Error("Transport key not found or expired");let l=x(d.ephemeralPublicKey),p=await crypto.subtle.importKey("raw",l,{name:"ECDH",namedCurve:"P-256"},!1,[]),f=await crypto.subtle.deriveBits({name:"ECDH",public:p},c.privateKey,256),y=await crypto.subtle.importKey("raw",f,"HKDF",!1,["deriveBits"]),w=await crypto.subtle.deriveBits({name:"HKDF",salt:new Uint8Array(32),info:new TextEncoder().encode("ATS/KMS/setup-transport/v2"),hash:"SHA-256"},y,256),K=await crypto.subtle.importKey("raw",w,{name:"AES-GCM",length:256},!1,["decrypt"]),b=x(d.iv),h=x(d.encryptedCredentials),v=await crypto.subtle.decrypt({name:"AES-GCM",iv:b,tagLength:128},K,h),E=JSON.parse(new TextDecoder().decode(v));O.delete(d.transportKeyId);let A=d.method,m;if(A==="passphrase")m=await fe(r,E.passphrase,a);else if(A==="passkey-prf"){let k=E,T=k.rpId||"";m=await we(r,x(k.credentialId),x(k.prfOutput),a,T)}else if(A==="passkey-gate"){let k=E,T=k.rpId||"";m=await ge(r,x(k.credentialId),a,T)}else{let k=A;throw new Error(`Unknown enrollment method: ${String(k)}`)}if(a.fill(0),!m.success)throw new Error(m.error);return await R({op:"add-enrollment",kid:"",requestId:t,userId:n.userId,details:{method:A,action:"add-enrollment"}}),{success:!0,enrollmentId:`enrollment:${A}:v2`}}async function Qt(e,t){let{userId:r}=e,n=await Re(),s=new URL("https://kms.ats.run/");s.searchParams.set("mode","setup");let a=await new Promise((A,m)=>{let k=setTimeout(()=>{console.error("[Worker] Popup timeout after 5 minutes"),m(new Error("Add enrollment popup timeout"))},3e5);$.set(t,{resolve:A,reject:m,timeout:k}),self.postMessage({type:"worker:setup-with-popup",requestId:t,userId:r,popupURL:s.toString(),transportKey:n.publicKey,transportKeyId:n.keyId,appSalt:n.appSalt,hkdfSalt:n.hkdfSalt})}),i=O.get(a.transportKeyId);if(!i)throw new Error("Transport key not found or expired");let o=x(a.ephemeralPublicKey),u=await crypto.subtle.importKey("raw",o,{name:"ECDH",namedCurve:"P-256"},!1,[]),d=await crypto.subtle.deriveBits({name:"ECDH",public:u},i.privateKey,256),c=await crypto.subtle.importKey("raw",d,"HKDF",!1,["deriveBits"]),l=await crypto.subtle.deriveBits({name:"HKDF",salt:new Uint8Array(32),info:new TextEncoder().encode("ATS/KMS/setup-transport/v2"),hash:"SHA-256"},c,256),p=await crypto.subtle.importKey("raw",l,{name:"AES-GCM",length:256},!1,["decrypt"]),f=x(a.iv),y=x(a.encryptedCredentials),w=await crypto.subtle.decrypt({name:"AES-GCM",iv:f,tagLength:128},p,y),K=JSON.parse(new TextDecoder().decode(w));O.delete(a.transportKeyId);let b=await new Promise((A,m)=>{let k=setTimeout(()=>{console.error("[Worker] Unlock timeout after 5 minutes"),m(new Error("Unlock modal timeout"))},3e5);ie.set(t,{resolve:A,reject:m,timeout:k}),self.postMessage({type:"worker:request-unlock",requestId:t,userId:r})}),v=(await B(b,async(A,m)=>(await L(A),new Uint8Array(m)))).result,E=a.method;try{let A;if(E==="passphrase")A=await fe(r,K.passphrase,v);else if(E==="passkey-prf"){let m=K,k=m.rpId||"";A=await we(r,x(m.credentialId),x(m.prfOutput),v,k)}else if(E==="passkey-gate"){let m=K,k=m.rpId||"";A=await ge(r,x(m.credentialId),v,k)}else{let m=E;throw new Error(`Unknown enrollment method: ${String(m)}`)}if(!A.success)throw new Error(A.error)}finally{v.fill(0)}return await R({op:"add-enrollment-with-popup",kid:"",requestId:t,userId:r,details:{method:E,action:"add-enrollment-with-popup"}}),{success:!0,enrollmentId:`enrollment:${E}:v2`}}async function Xt(e,t){let{credentials:r}=e,n=await B(r,async(s,a)=>{await L(s);let i=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"]);if(!("privateKey"in i)||!("publicKey"in i))throw new Error("Failed to generate ECDSA keypair");let o=i,u=await crypto.subtle.exportKey("raw",o.publicKey),d=N(new Uint8Array(u)),c=await J(d);return await M(o.privateKey,s,c,{name:"ECDSA",namedCurve:"P-256"},["sign"],{alg:"ES256",purpose:"vapid",publicKeyRaw:u}),{kid:c,publicKey:g(u)}});return await R({op:"generate",kid:n.result.kid,requestId:t,userId:r.userId,unlockTime:n.unlockTime,lockTime:n.lockTime,duration:n.duration,details:{algorithm:"ECDSA",curve:"P-256",purpose:"vapid"}}),n.result}async function Yt(e,t){let{credentials:r}=e,n=await B(r,async(s,a)=>{await L(s);let o=(await V()).filter(f=>f.purpose==="vapid");for(let f of o)await Oe(f.kid);let u=await crypto.subtle.generateKey({name:"ECDSA",namedCurve:"P-256"},!0,["sign","verify"]);if(!("privateKey"in u)||!("publicKey"in u))throw new Error("Failed to generate ECDSA keypair");let d=u,c=await crypto.subtle.exportKey("raw",d.publicKey),l=N(new Uint8Array(c)),p=await J(l);return await M(d.privateKey,s,p,{name:"ECDSA",namedCurve:"P-256"},["sign"],{alg:"ES256",purpose:"vapid",publicKeyRaw:c}),{kid:p,publicKey:g(c),oldKids:o.map(f=>f.kid)}});return await R({op:"regenerate-vapid",kid:n.result.kid,requestId:t,userId:r.userId,unlockTime:n.unlockTime,lockTime:n.lockTime,duration:n.duration,details:{algorithm:"ECDSA",curve:"P-256",purpose:"vapid",oldKids:n.result.oldKids,deletedCount:n.result.oldKids.length}}),{kid:n.result.kid,publicKey:n.result.publicKey}}async function Zt(e,t){let{kid:r,payload:n,credentials:s}=e;if(!n.aud||!n.sub||!n.exp)throw new Error("JWT payload must include aud, sub, and exp");let a=Math.floor(Date.now()/1e3);if(n.exp<=a)throw new Error("JWT exp must be in the future");if(n.exp>a+86400)throw new Error("JWT exp must be <= 24 hours (RFC 8292)");let i=await B(s,async(o,u)=>{await L(o);let d=await He(r,o,{name:"ECDSA",namedCurve:"P-256"},["sign"]),c={typ:"JWT",alg:"ES256",kid:r},l=g(new TextEncoder().encode(JSON.stringify(c)).buffer),p=g(new TextEncoder().encode(JSON.stringify(n)).buffer),f=new TextEncoder().encode(`${l}.${p}`),y=await crypto.subtle.sign({name:"ECDSA",hash:"SHA-256"},d,f),w=g(y);return{jwt:`${l}.${p}.${w}`}});return await R({op:"sign",kid:r,requestId:t,userId:s.userId,unlockTime:i.unlockTime,lockTime:i.lockTime,duration:i.duration,details:{algorithm:"ES256",aud:n.aud,exp:n.exp,jti:n.jti}}),i.result}async function Pt(e,t){let{userId:r,ttlHours:n,credentials:s,autoExtend:a}=e;if(n<=0||n>720)throw new Error("ttlHours must be between 0 and 720 (30 days)");let o=(await V()).filter(b=>b.purpose==="vapid");if(o.length===0)throw new Error("No VAPID key found. VAPID key should have been generated during setup.");o.sort((b,h)=>h.createdAt-b.createdAt);let u=o[0];if(!u)throw new Error("VAPID key record not found after filtering");let d=u.kid,c=`lease-${crypto.randomUUID()}`,l=crypto.getRandomValues(new Uint8Array(32)),p=Date.now(),f=p+n*3600*1e3,y=await B(s,async(b,h)=>{await L(b);let{delegationCert:v}=await Ne(c,f),E=await Gt(h,l),A=await H(d);if(!A)throw new Error(`No wrapped key with id: ${d}`);let m=new Uint8Array(A.iv),k=A.aad,T=await crypto.subtle.unwrapKey("pkcs8",A.wrappedKey,b,{name:"AES-GCM",iv:m,additionalData:k},{name:"ECDSA",namedCurve:"P-256"},!0,["sign"]),G=crypto.getRandomValues(new Uint8Array(12));return{wrappedLeaseKey:await crypto.subtle.wrapKey("pkcs8",T,E,{name:"AES-GCM",iv:G}),iv:G,sessionKEK:E,lakDelegationCert:v}});await U(`sessionkek:${c}`,y.result.sessionKEK),De.set(c,y.result.sessionKEK);let w={tokensPerHour:100,sendsPerMinute:10,burstSends:20,sendsPerMinutePerEid:5},K={leaseId:c,userId:r,ttlHours:n,createdAt:p,exp:f,autoExtend:a??!0,quotas:w,wrappedLeaseKey:y.result.wrappedLeaseKey,wrappedLeaseKeyIV:y.result.iv.buffer.slice(y.result.iv.byteOffset,y.result.iv.byteOffset+y.result.iv.byteLength),leaseSalt:l.buffer.slice(l.byteOffset,l.byteOffset+l.byteLength),kid:d,lakDelegationCert:y.result.lakDelegationCert};return await be(K),await U(`quota:${c}`,{leaseId:c,tokensIssued:0,lastResetAt:p,perEndpoint:{}}),await R({op:"create-lease",kid:d,requestId:t,userId:r,details:{action:"create-lease",leaseId:c,userId:r,ttlHours:n,autoExtend:K.autoExtend}}),{leaseId:c,exp:f,quotas:w,autoExtend:K.autoExtend??!0}}async function er(e,t){let{leaseIds:r,credentials:n,requestAuth:s}=e,a=[],i=0,o=0,u=0,d=!1;if(n)try{await B(n,async(c,l)=>(d=!0,Promise.resolve()))}catch(c){for(let l of r){let p=await ee(l);p&&p.autoExtend===!1&&(a.push({leaseId:l,status:"skipped",reason:`Authentication failed: ${se(c)}`}),o++)}if(o===r.length)return{results:a,extended:i,skipped:o,failed:u}}for(let c of r)try{let l=await ee(c);if(!l){a.push({leaseId:c,status:"skipped",reason:`Lease not found: ${c}`}),o++;continue}if(l.autoExtend===!1&&!s){a.push({leaseId:c,status:"skipped",reason:"Lease has autoExtend=false and authentication was not requested"}),o++;continue}if(l.autoExtend===!1&&s&&!d){a.push({leaseId:c,status:"skipped",reason:"Authentication required but credentials not valid"}),o++;continue}let f=(await V()).filter(v=>v.purpose==="vapid");if(f.length===0){a.push({leaseId:c,status:"skipped",reason:"No VAPID key found"}),o++;continue}f.sort((v,E)=>E.createdAt-v.createdAt);let w=f[0].kid;if(l.kid!==w){a.push({leaseId:c,status:"skipped",reason:`Lease is for different VAPID key (lease kid: ${l.kid}, current kid: ${w})`}),o++;continue}let K=Date.now(),b=K+30*24*60*60*1e3,h={...l,exp:b,createdAt:K};await be(h),await R({op:"extend-lease",kid:h.kid,requestId:t,userId:h.userId,details:{action:"extend-lease",leaseId:h.leaseId,userId:h.userId,newExp:b,autoExtend:h.autoExtend}}),a.push({leaseId:c,status:"extended",result:{leaseId:h.leaseId,exp:h.exp,iat:h.createdAt,kid:h.kid,autoExtend:h.autoExtend??!1}}),i++}catch(l){a.push({leaseId:c,status:"skipped",reason:`Error extending lease: ${se(l)}`}),u++}return{results:a,extended:i,skipped:o,failed:u}}async function St(e,t){let{leaseId:r}=e,{kid:n}=e;if(!n){let Y=(await V()).filter(Rt=>Rt.purpose==="vapid");if(Y.length===0)throw new Error("No VAPID key found. Create a lease first to auto-generate one.");if(Y.length>1)throw new Error("Multiple VAPID keys found. Please specify kid explicitly.");let Ve=Y[0];if(!Ve)throw new Error("No VAPID key found after filtering");n=Ve.kid}let s=await ee(r);if(!s)throw new Error(`Lease not found: ${r}`);if(Date.now()>=s.exp)throw new Error("Lease expired");let i=(await V()).filter(j=>j.purpose==="vapid");if(i.length===0)throw new Error("No VAPID key available");i.sort((j,Y)=>Y.createdAt-j.createdAt);let o=i[0]?.kid;if(!o)throw new Error("Failed to determine current VAPID key");if(s.kid!==o)throw new Error("Lease invalidated by VAPID key rotation (wrong-key)");await Je(r,s.lakDelegationCert);let u=await Ae();if(!u)throw new Error("No push subscription found. Call setPushSubscription() first.");let d=await C(`quota:${r}`),c=bt(d),l=Date.now()-3600*1e3;if(c.lastResetAt<l&&(c.tokensIssued=0,c.lastResetAt=Date.now()),c.tokensIssued>=s.quotas.tokensPerHour)throw new Error("Quota exceeded: tokens per hour");c.tokensIssued++,await U(`quota:${r}`,c);let p=e.jti??crypto.randomUUID(),f=e.exp??Math.floor(Date.now()/1e3)+900,y=new URL(u.endpoint),w=`${y.protocol}//${y.host}`,K={aud:w,sub:"mailto:admin@allthe.services",exp:f,jti:p,uid:s.userId,eid:u.eid},b=De.get(r);if(!b){let j=await C(`sessionkek:${r}`);if(!j)throw new Error(`SessionKEK not found for lease: ${r}`);b=j,De.set(r,b)}let h=s.wrappedLeaseKey,v=new Uint8Array(s.wrappedLeaseKeyIV),E=await crypto.subtle.unwrapKey("pkcs8",h,b,{name:"AES-GCM",iv:v},{name:"ECDSA",namedCurve:"P-256"},!1,["sign"]),A={typ:"JWT",alg:"ES256",kid:s.kid},m=g(new TextEncoder().encode(JSON.stringify(A)).buffer),k=g(new TextEncoder().encode(JSON.stringify(K)).buffer),T=new TextEncoder().encode(`${m}.${k}`),G=await crypto.subtle.sign({name:"ECDSA",hash:"SHA-256"},E,T),Te=g(G),Ct=`${m}.${k}.${Te}`,Dt=await R({op:"sign",kid:s.kid,requestId:t,userId:s.userId,leaseId:r,details:{action:"issue-lease-jwt",jti:p,aud:w,eid:u.eid}});return{jwt:Ct,jti:p,exp:f,auditEntry:Dt}}async function Et(e,t){let{leaseId:r,count:n,kid:s}=e;if(!Number.isInteger(n)||n<1||n>10)throw new Error("count must be an integer between 1 and 10");let a=900,i=Math.floor(a*.6),o=Math.floor(Date.now()/1e3),u=[];for(let d=0;d<n;d++){let c=crypto.randomUUID(),l=o+a+d*i,p=await St({leaseId:r,...s!==void 0&&{kid:s},jti:c,exp:l},`${t}-${d}`);u.push(p)}return u}async function tr(e){let t=e?.userId??"default",r=await ve(t),n=[];await Pe(t)&&n.push("passphrase"),await Se(t)&&n.push("passkey");let s;return r&&e?.userId&&(s=await Ke(e.userId)),{isSetup:r,methods:n,...s!==void 0&&{leases:s}}}async function rr(e){let t=e?.userId??"default",r=[];if(await Pe(t)&&r.push("enrollment:passphrase:v2"),await Se(t)){let n=await C(`enrollment:passkey-prf:v2:${t}`),s=await C(`enrollment:passkey-gate:v2:${t}`);n&&r.push("enrollment:passkey-prf:v2"),s&&r.push("enrollment:passkey-gate:v2")}return{enrollments:r}}async function nr(){return await ze()}async function sr(){return{entries:await Q()}}async function ar(e){let{kid:t}=e,r=await H(t);if(!r||!r.publicKeyRaw)throw new Error(`Public key not found for kid: ${t}`);return{publicKey:g(r.publicKeyRaw)}}async function ir(){return await Qe()}async function or(e){let{userId:t}=e;return{leases:await Ke(t)}}async function ur(e){let{leaseId:t,deleteIfInvalid:r=!1}=e,n=await ee(t);if(!n)return{leaseId:t,valid:!1,reason:"not-found",kid:""};if(Date.now()>=n.exp)return r&&await te(t),{leaseId:t,valid:!1,reason:"expired",kid:n.kid};let a=(await V()).filter(u=>u.purpose==="vapid");if(a.length===0)return r&&await te(t),{leaseId:t,valid:!1,reason:"no-vapid-key",kid:n.kid};a.sort((u,d)=>d.createdAt-u.createdAt);let i=a[0];if(!i)return r&&await te(t),{leaseId:t,valid:!1,reason:"no-vapid-key",kid:n.kid};let o=i.kid;return n.kid!==o?(r&&await te(t),{leaseId:t,valid:!1,reason:"wrong-key",kid:n.kid}):{leaseId:t,valid:!0,kid:n.kid}}async function dr(){let t=(await V()).filter(n=>n.purpose==="vapid");if(t.length===0)throw new Error("No VAPID key found");if(t.length>1)throw new Error("Multiple VAPID keys found. Please use getPublicKey(kid) with explicit kid.");let r=t[0];if(!r)throw new Error("No VAPID key found after filtering");return{kid:r.kid}}async function xt(e){return await Fe(e.subscription),{success:!0}}async function cr(){return await $e(),{success:!0}}async function lr(){return{subscription:await Ae()}}async function pr(){Be();let e=indexedDB.deleteDatabase("kms-v2");return await new Promise((t,r)=>{e.onsuccess=()=>t(),e.onerror=()=>r(new Error(e.error?.message??"Failed to delete database"))}),await de(),Xe(),{success:!0}}async function yr(e,t){let{enrollmentId:r,credentials:n}=e;return await B(n,async(s,a)=>(await L(s),!0)),await je(r),await R({op:"reset",kid:"",requestId:t,userId:n.userId,details:{action:"remove-enrollment",enrollmentId:r}}),{success:!0}}(async()=>{try{await de(),await Ge(),await _e(),(await Q()).length===0&&await R({op:"kms-init",kid:"",requestId:`init-${Date.now()}`,userId:"system",details:{kmsVersion:"v2.0.0",timestamp:new Date().toISOString(),note:"KMS worker initialized, KIAK generated"}})}catch(e){console.error("[KMS Worker] Initialization failed:",e)}})();export{_t as handleMessage};
