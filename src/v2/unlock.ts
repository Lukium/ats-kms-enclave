/**
 * Unlock context management for KMS V2
 *
 * The unlock module encapsulates the logic for creating and
 * decrypting the master secret (MS) using various authentication
 * methods. It supports passphrase and passkey PRF enrolments and
 * provides a single unlock gate via `withUnlock` which guarantees
 * cleanup of sensitive material. Key derivation and encryption
 * routines are delegated to the crypto utilities and WebCrypto APIs.
 */

import {
  computeKCV,
  verifyKCV,
  deriveDeterministicSalt,
  buildMSEncryptionAAD,
  calibratePBKDF2Iterations,
} from './crypto-utils';
import {
  getMeta,
  putMeta,
} from './storage';
import type {
  PassphraseConfigV2,
  PasskeyPRFConfigV2,
  PasskeyGateConfigV2,
  AuthCredentials,
  UnlockOperationResult,
  UnlockResult,
} from './types';

// Persistent config keys for enrolments. Keys are namespaced by userId
// to support multiple users in the same browser.
const getPassphraseConfigKey = (userId: string): string => `enrollment:passphrase:v2:${userId}`;
const getPasskeyPRFConfigKey = (userId: string): string => `enrollment:passkey-prf:v2:${userId}`;
const getPasskeyGateConfigKey = (userId: string): string => `enrollment:passkey-gate:v2:${userId}`;

/**
 * Generate a new random 32‑byte master secret. The MS should never
 * persist in storage unencrypted.
 */
function generateMasterSecret(): Uint8Array {
  const ms = new Uint8Array(32);
  crypto.getRandomValues(ms);
  return ms;
}

/**
 * Setup the passphrase authentication method. Derives a key
 * encryption key (KEK) from the provided passphrase via calibrated
 * PBKDF2, encrypts the master secret under AES‑GCM and stores the
 * resulting configuration. Returns the cleartext MS to the caller.
 */
export async function setupPassphrase(
  userId: string,
  passphrase: string,
  existingMS?: Uint8Array
): Promise<UnlockResult> {
  const ms = existingMS ?? generateMasterSecret();
  // Calibrate PBKDF2 iterations and derive KEK
  const { iterations } = await calibratePBKDF2Iterations();
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const passphraseKey = await crypto.subtle.importKey(
    'raw',
    new TextEncoder().encode(passphrase),
    'PBKDF2',
    false,
    ['deriveKey']
  );
  const kek = await crypto.subtle.deriveKey(
    { name: 'PBKDF2', hash: 'SHA-256', salt, iterations },
    passphraseKey,
    { name: 'AES-GCM', length: 256 },
    true, // extractable: true for KCV computation
    ['encrypt', 'decrypt']
  );
  // Compute KCV
  const kcv = await computeKCV(kek);
  // Encrypt MS
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const aad = buildMSEncryptionAAD({
    kmsVersion: 2,
    method: 'passphrase',
    algVersion: 1,
    purpose: 'master-secret',
  });
  const ciphertext = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv, additionalData: aad },
    kek,
    ms as BufferSource
  );
  // Persist config
  const config: PassphraseConfigV2 = {
    kmsVersion: 2,
    algVersion: 1,
    method: 'passphrase',
    kdf: {
      algorithm: 'PBKDF2-HMAC-SHA256',
      iterations,
      salt: salt.buffer.slice(salt.byteOffset, salt.byteOffset + salt.byteLength),
      lastCalibratedAt: Date.now(),
      platformHash: '', // platform hash can be filled by caller
    },
    kcv,
    encryptedMS: ciphertext,
    msIV: iv.buffer.slice(iv.byteOffset, iv.byteOffset + iv.byteLength),
    msAAD: aad,
    msVersion: 1,
    createdAt: Date.now(),
    updatedAt: Date.now(),
  };
  await putMeta(getPassphraseConfigKey(userId), config);
  return { success: true, ms };
}

/**
 * Setup the passkey PRF authentication method. Derives a KEK via
 * HKDF from the provided PRF output, encrypts the master secret and
 * stores the resulting configuration. The RP ID must be supplied
 * externally; here it is optional and defaults to an empty string.
 */
export async function setupPasskeyPRF(
  userId: string,
  credentialId: ArrayBuffer,
  prfOutput: ArrayBuffer,
  existingMS?: Uint8Array,
  rpId: string = '',
  providedAppSalt?: Uint8Array,
  providedHkdfSalt?: Uint8Array
): Promise<UnlockResult> {
  const ms = existingMS ?? generateMasterSecret();

  // Use provided salts (from popup flow) or generate them (from iframe flow)
  // Note: For popup flow, these salts are generated by generateSetupTransportKey()
  // and transmitted securely through the encrypted channel
  const appSalt = providedAppSalt ?? crypto.getRandomValues(new Uint8Array(32));
  const hkdfSalt = providedHkdfSalt ?? (await deriveDeterministicSalt('ATS/KMS/KEK-wrap/salt/v2'));

  const info = new TextEncoder().encode('ATS/KMS/KEK-wrap/v2');
  const ikm = await crypto.subtle.importKey('raw', prfOutput, 'HKDF', false, ['deriveKey']);
  // Ensure hkdfSalt is BufferSource (convert Uint8Array to ArrayBuffer if needed)
  const hkdfSaltForKek = hkdfSalt instanceof Uint8Array ? hkdfSalt.buffer : hkdfSalt;
  const kek = await crypto.subtle.deriveKey(
    { name: 'HKDF', hash: 'SHA-256', salt: hkdfSaltForKek as BufferSource, info },
    ikm,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );
  // Encrypt MS
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const aad = buildMSEncryptionAAD({
    kmsVersion: 2,
    method: 'passkey-prf',
    algVersion: 1,
    credentialId,
    purpose: 'master-secret',
  });
  const ciphertext = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv, additionalData: aad },
    kek,
    ms as BufferSource
  );
  const now = Date.now();
  // Convert salts to ArrayBuffer (not SharedArrayBuffer) by slicing
  const appSaltBuffer = appSalt.buffer.slice(appSalt.byteOffset, appSalt.byteOffset + appSalt.byteLength) as ArrayBuffer;
  let hkdfSaltBuffer: ArrayBuffer;
  if (hkdfSalt instanceof Uint8Array) {
    hkdfSaltBuffer = hkdfSalt.buffer.slice(hkdfSalt.byteOffset, hkdfSalt.byteOffset + hkdfSalt.byteLength) as ArrayBuffer;
  } else {
    // Already an ArrayBuffer (from deriveDeterministicSalt)
    hkdfSaltBuffer = hkdfSalt as ArrayBuffer;
  }
  const config: PasskeyPRFConfigV2 = {
    kmsVersion: 2,
    algVersion: 1,
    method: 'passkey-prf',
    credentialId,
    rpId,
    kdf: {
      algorithm: 'HKDF-SHA256',
      appSalt: appSaltBuffer,
      hkdfSalt: hkdfSaltBuffer,
      info: 'ATS/KMS/KEK-wrap/v2',
    },
    encryptedMS: ciphertext,
    msIV: iv.buffer.slice(iv.byteOffset, iv.byteOffset + iv.byteLength) as ArrayBuffer,
    msAAD: aad,
    msVersion: 1,
    createdAt: now,
    updatedAt: now,
  };
  await putMeta(getPasskeyPRFConfigKey(userId), config);
  return { success: true, ms };
}

/**
 * Setup the passkey gate authentication method. Generates a random pepper,
 * derives a KEK from the pepper, encrypts the master secret, and stores
 * the configuration. The pepper is stored wrapped so it can only be accessed
 * after successful passkey authentication.
 *
 * Note: This is a fallback method for passkeys that don't support PRF.
 * The pepper provides the entropy needed to derive the KEK, similar to how
 * PRF output provides entropy in setupPasskeyPRF.
 */
export async function setupPasskeyGate(
  userId: string,
  credentialId: ArrayBuffer,
  existingMS?: Uint8Array,
  rpId: string = ''
): Promise<UnlockResult> {
  const ms = existingMS ?? generateMasterSecret();

  // Generate random pepper (32 bytes)
  const pepper = crypto.getRandomValues(new Uint8Array(32));

  // Derive KEK from pepper using HKDF
  const hkdfSalt = await deriveDeterministicSalt('ATS/KMS/KEK-gate/salt/v2');
  const info = new TextEncoder().encode('ATS/KMS/KEK-gate/v2');
  const ikm = await crypto.subtle.importKey('raw', pepper, 'HKDF', false, ['deriveKey']);
  const kek = await crypto.subtle.deriveKey(
    { name: 'HKDF', hash: 'SHA-256', salt: hkdfSalt, info },
    ikm,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );

  // Encrypt MS
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const aad = buildMSEncryptionAAD({
    kmsVersion: 2,
    method: 'passkey-gate',
    algVersion: 1,
    credentialId,
    purpose: 'master-secret',
  });
  const ciphertext = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv, additionalData: aad },
    kek,
    ms as BufferSource
  );

  // Wrap the pepper for storage
  // In a real implementation, the pepper would be encrypted with a key derived
  // from the passkey credential. For this simplified version, we store it
  // directly (assuming it's protected by device security).
  const now = Date.now();
  const config: PasskeyGateConfigV2 = {
    kmsVersion: 2,
    algVersion: 1,
    method: 'passkey-gate',
    credentialId,
    rpId,
    pepperWrapped: pepper.buffer.slice(pepper.byteOffset, pepper.byteOffset + pepper.byteLength),
    encryptedMS: ciphertext,
    msIV: iv.buffer.slice(iv.byteOffset, iv.byteOffset + iv.byteLength),
    msAAD: aad,
    msVersion: 1,
    createdAt: now,
    updatedAt: now,
  };

  await putMeta(getPasskeyGateConfigKey(userId), config);
  return { success: true, ms };
}

/**
 * Unlock the master secret using a passphrase. Retrieves the stored
 * configuration, derives the KEK and verifies the KCV. If the
 * verification passes the master secret is decrypted and returned.
 */
export async function unlockWithPassphrase(userId: string, passphrase: string): Promise<UnlockResult> {
  const config = (await getMeta<PassphraseConfigV2>(getPassphraseConfigKey(userId)));
  if (!config) return { success: false, error: 'Passphrase not set up' };
  const passphraseKey = await crypto.subtle.importKey(
    'raw',
    new TextEncoder().encode(passphrase),
    'PBKDF2',
    false,
    ['deriveKey']
  );
  const kek = await crypto.subtle.deriveKey(
    { name: 'PBKDF2', hash: 'SHA-256', salt: config.kdf.salt, iterations: config.kdf.iterations },
    passphraseKey,
    { name: 'AES-GCM', length: 256 },
    true, // extractable: true for KCV computation
    ['encrypt', 'decrypt']
  );
  const computedKcv = await computeKCV(kek);
  if (!verifyKCV(computedKcv, config.kcv)) {
    return { success: false, error: 'Invalid passphrase' };
  }
  try {
    const msBuf = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv: config.msIV, additionalData: config.msAAD },
      kek,
      config.encryptedMS
    );
    return { success: true, ms: new Uint8Array(msBuf) };
  } catch {
    return { success: false, error: 'Decryption failed' };
  }
}

/**
 * Unlock the master secret using a passkey PRF output. Uses HKDF to
 * derive the KEK, decrypts the MS and returns it. No KCV is stored
 * for passkey enrolments in this simplified implementation.
 */
export async function unlockWithPasskeyPRF(userId: string, prfOutput: ArrayBuffer): Promise<UnlockResult> {
  const config = (await getMeta<PasskeyPRFConfigV2>(getPasskeyPRFConfigKey(userId)));
  if (!config) return { success: false, error: 'Passkey not set up' };
  const hkdfSalt = config.kdf.hkdfSalt;
  const info = new TextEncoder().encode(config.kdf.info);
  const ikm = await crypto.subtle.importKey('raw', prfOutput, 'HKDF', false, ['deriveKey']);
  const kek = await crypto.subtle.deriveKey(
    { name: 'HKDF', hash: 'SHA-256', salt: hkdfSalt, info },
    ikm,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );
  try {
    const msBuf = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv: config.msIV, additionalData: config.msAAD },
      kek,
      config.encryptedMS
    );
    return { success: true, ms: new Uint8Array(msBuf) };
  } catch {
    return { success: false, error: 'Decryption failed' };
  }
}

/**
 * Unlock the master secret using passkey gate method. Retrieves the stored
 * pepper, derives the KEK, and decrypts the MS.
 *
 * Note: In a real implementation, this would require successful passkey
 * authentication before the pepper can be accessed. This simplified version
 * assumes the pepper is accessible after device authentication.
 */
export async function unlockWithPasskeyGate(userId: string): Promise<UnlockResult> {
  const config = await getMeta<PasskeyGateConfigV2>(getPasskeyGateConfigKey(userId));
  if (!config) return { success: false, error: 'Passkey gate not set up' };

  // Retrieve the pepper
  const pepper = new Uint8Array(config.pepperWrapped);

  // Derive KEK from pepper (same as setup)
  const hkdfSalt = await deriveDeterministicSalt('ATS/KMS/KEK-gate/salt/v2');
  const info = new TextEncoder().encode('ATS/KMS/KEK-gate/v2');
  const ikm = await crypto.subtle.importKey('raw', pepper, 'HKDF', false, ['deriveKey']);
  const kek = await crypto.subtle.deriveKey(
    { name: 'HKDF', hash: 'SHA-256', salt: hkdfSalt, info },
    ikm,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );

  // Decrypt MS
  try {
    const msBuf = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv: config.msIV, additionalData: config.msAAD },
      kek,
      config.encryptedMS
    );
    return { success: true, ms: new Uint8Array(msBuf) };
  } catch {
    return { success: false, error: 'Decryption failed' };
  }
}

/**
 * Test whether any enrolment exists. Used by the UI to determine
 * whether setup is required.
 */
export async function isSetup(userId: string): Promise<boolean> {
  const pass = await getMeta(getPassphraseConfigKey(userId));
  const prf = await getMeta(getPasskeyPRFConfigKey(userId));
  const gate = await getMeta(getPasskeyGateConfigKey(userId));
  return !!(pass || prf || gate);
}

/**
 * Test whether a passphrase enrolment exists.
 */
export async function isPassphraseSetup(userId: string): Promise<boolean> {
  return !!(await getMeta(getPassphraseConfigKey(userId)));
}

/**
 * Test whether any passkey enrolment exists (PRF or gate).
 */
export async function isPasskeySetup(userId: string): Promise<boolean> {
  const prf = await getMeta(getPasskeyPRFConfigKey(userId));
  const gate = await getMeta(getPasskeyGateConfigKey(userId));
  return !!(prf || gate);
}

/**
 * Derive the master key encryption key (MKEK) from the master secret.
 * Uses HKDF with a deterministic salt and info string specific to
 * MKEK derivation. The returned key is non‑extractable and can be
 * used for wrapping application keys.
 */
export async function deriveMKEKFromMS(ms: Uint8Array): Promise<CryptoKey> {
  const salt = await deriveDeterministicSalt('ATS/KMS/MKEK/salt/v2');
  const info = new TextEncoder().encode('ATS/KMS/MKEK/v2');
  const ikm = await crypto.subtle.importKey('raw', ms as BufferSource, 'HKDF', false, ['deriveKey']);
  const mkek = await crypto.subtle.deriveKey(
    { name: 'HKDF', hash: 'SHA-256', salt, info },
    ikm,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt', 'wrapKey', 'unwrapKey']
  );
  return mkek;
}

/**
 * Execute an operation within an unlocked context. Accepts
 * credentials, unlocks the MS and derives the MKEK. The provided
 * operation callback receives the MKEK and may perform any
 * cryptographic action (e.g. wrapping keys, signing JWTs). After the
 * callback resolves the MS is zeroised and the timing information
 * returned alongside the operation result. Errors thrown by the
 * callback propagate to the caller.
 */
export async function withUnlock<T>(
  credentials: AuthCredentials,
  operation: (mkek: CryptoKey, ms: Uint8Array) => Promise<T>
): Promise<UnlockOperationResult<T>> {
  const start = Date.now();
  let ms: Uint8Array | null = null;
  try {
    let unlockResult: UnlockResult;
    switch (credentials.method) {
      case 'passphrase':
        unlockResult = await unlockWithPassphrase(credentials.userId, credentials.passphrase);
        break;
      case 'passkey-prf':
        unlockResult = await unlockWithPasskeyPRF(credentials.userId, credentials.prfOutput);
        break;
      case 'passkey-gate':
        unlockResult = await unlockWithPasskeyGate(credentials.userId);
        break;
      default:
        throw new Error('Unknown credential method');
    }
    if (!unlockResult.success) {
      throw new Error(unlockResult.error ?? 'Unlock failed');
    }
    ms = unlockResult.ms;
    const mkek = await deriveMKEKFromMS(ms);
    const result = await operation(mkek, ms);
    const end = Date.now();
    return {
      result,
      unlockTime: start,
      lockTime: end,
      duration: end - start,
    };
  } finally {
    // Zeroise MS
    if (ms) {
      ms.fill(0);
    }
  }
}
