#!/usr/bin/env tsx
/**
 * Generate Verification Report (Markdown)
 *
 * Creates a detailed markdown report from verification results.
 * This report is committed to the `attestation` branch as README.md
 *
 * Part of Phase 2.1: Verifiable Builds
 */

import type { VerificationResult } from './verify-deployment.js';

interface ReportData {
  result: VerificationResult;
  runUrl?: string;
}

/**
 * Format timestamp as human-readable
 */
function formatTimestamp(timestamp: string): string {
  const date = new Date(timestamp);
  return date.toUTCString();
}

/**
 * Generate markdown report from verification result
 */
export function generateReport(data: ReportData): string {
  const { result, runUrl } = data;
  const status = result.allPassed ? 'âœ… VERIFIED' : 'âŒ FAILED';
  const statusEmoji = result.allPassed ? 'âœ…' : 'âŒ';

  const report = `# ðŸ” KMS Verification Report

**Status:** ${status}
**Timestamp:** ${formatTimestamp(result.timestamp)}
**Worker Hash:** ${result.manifest?.current.sha256.substring(0, 8) || 'unknown'}
${runUrl ? `**Workflow Run:** [View Details](${runUrl})` : ''}

---

## Verification Results

${result.checks.map(check => {
  const checkStatus = check.passed ? 'âœ…' : 'âŒ';
  let details = '';

  if (check.details) {
    if (check.name === 'Worker Hash' && check.details.expected) {
      details = `

**Expected Hash:**
\`\`\`
${check.details.expected}
\`\`\`

**Actual Hash:**
\`\`\`
${check.details.actual}
\`\`\`

**Source:** ${check.details.url}`;
    } else if (check.name === 'SRI Hashes' && Array.isArray(check.details)) {
      details = '\n\n' + check.details.map((d: any) => {
        if (d.expected && d.actual) {
          const status = d.passed ? 'âœ…' : 'âŒ';
          return `#### ${d.name} ${status}

**Expected SRI:**
\`\`\`
${d.expected}
\`\`\`

**Actual SRI:**
\`\`\`
${d.actual}
\`\`\`

**Source:** ${d.url}`;
        } else {
          return `#### ${d.name} âŒ

${d.message}`;
        }
      }).join('\n\n');
    } else if (check.name === 'Security Headers' && Array.isArray(check.details)) {
      details = '\n\n' + check.details.map((h: any) => {
        let headerDetails = '';

        // Add CSP frame-ancestors explanation
        if (h.name === 'content-security-policy' && h.passed) {
          headerDetails = `

**Frame Ancestors Explanation:**
The \`frame-ancestors\` directive controls which origins can embed the KMS enclave in an iframe:

- \`https://alpha.allthe.services\` - Development build of the AllTheServices app
- \`https://beta.allthe.services\` - Beta build (not yet available)
- \`https://allthe.services\` - Production build (not yet available)
- \`https://phase2-demo.allthe.services\` - Demo for the KMS enclave itself
- \`http://localhost:5173\` - Local development counterpart of the dev build`;
        }

        if (h.passed) {
          return `#### ${h.name} âœ…

**Expected:** \`${h.expected}\`

**Actual:** âœ… Matches${headerDetails}`;
        } else {
          return `#### ${h.name} âŒ

**Expected:**
\`\`\`
${h.expected}
\`\`\`

**Actual:**
\`\`\`
${h.actual || '(missing)'}
\`\`\`

**Issue:** ${h.message}`;
        }
      }).join('\n\n');
    } else if (check.name === 'Allowed List' && check.details) {
      details = `

**Current Hash:** \`${check.details.currentHash}\`

**Allowed Hashes:**
${check.details.allowed.map((hash: string) => `- \`${hash}\``).join('\n')}`;
    }
  }

  return `### ${checkStatus} ${check.name}

${check.message}${details}
`;
}).join('\n')}

---

## Manifest Details

${result.manifest ? `
- **Version:** ${result.manifest.current.version}
- **Build Time:** ${new Date(parseInt(result.manifest.current.build.SOURCE_DATE_EPOCH) * 1000).toUTCString()}
- **Reproducible:** ${result.manifest.current.build.reproducible ? 'Yes' : 'No'}
- **Environment:** ${result.manifest.current.build.environment}

### Files
- **Worker:** \`${result.manifest.current.files.worker.filename}\`
  - SHA-256: \`${result.manifest.current.files.worker.sha256}\`
  - SRI: \`${result.manifest.current.files.worker.sri}\`

- **Client JS:** \`${result.manifest.current.files.client.filename}\`
  - SRI: \`${result.manifest.current.files.client.sri}\`

- **CSS:** \`${result.manifest.current.files.css.filename}\`
  - SRI: \`${result.manifest.current.files.css.sri}\`

### Allowed Versions
${result.manifest.allowed.map(hash => `- \`${hash.substring(0, 8)}...\``).join('\n')}
` : '*Manifest not available*'}

---

## About This Report

This report is automatically generated by the [KMS Verifier](https://github.com/lukium/ats-kms/tree/verifier).

The verifier runs approximately **4 times per day** at random times to check that the deployed KMS enclave matches the published manifest and security specifications.

### What Gets Verified:
1. Manifest integrity and structure
2. Worker hash matches deployed version
3. SRI (Subresource Integrity) hashes for all resources
4. Security headers (CSP, Permissions-Policy, etc.)
5. Current version is in allowed list
6. [Future] Rekor transparency log attestation

### Trust Model:
- **Verifier Code:** Frozen and auditable at specific commit
- **This Report:** Auto-generated, constantly updated
- **Badge:** Links to this report for transparency

---

*Last updated: ${formatTimestamp(result.timestamp)}*
*Verifier: [github.com/lukium/ats-kms/tree/verifier](https://github.com/lukium/ats-kms/tree/verifier)*
`;

  return report;
}

/**
 * Main entry point
 */
async function main() {
  const inputFile = process.argv[2];
  const runUrl = process.argv[3];

  if (!inputFile) {
    console.error('Usage: tsx generate-report.ts <verification-result.json> [runUrl]');
    process.exit(1);
  }

  const fs = await import('fs');
  const resultData = JSON.parse(fs.readFileSync(inputFile, 'utf-8'));

  const report = generateReport({
    result: resultData,
    runUrl,
  });

  console.log(report);
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}
